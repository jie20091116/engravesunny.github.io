{"meta":{"title":"刻猫猫的笔记本","subtitle":"此刻如黄金般闪耀","description":"用来记录每天的学习内容","author":"AliciaChi","url":"http://engravesunny.github.io","root":"/"},"pages":[{"title":"about","date":"2022-10-08T12:00:36.000Z","updated":"2022-10-08T15:14:03.377Z","comments":true,"path":"about/index.html","permalink":"http://engravesunny.github.io/about/index.html","excerpt":"","text":"在source&#x2F;about下写简历"},{"title":"追番","date":"2022-10-09T09:27:16.573Z","updated":"2022-10-09T09:27:16.573Z","comments":true,"path":"bangumis/index.html","permalink":"http://engravesunny.github.io/bangumis/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-10-08T11:59:55.000Z","updated":"2022-10-09T08:29:57.952Z","comments":true,"path":"categories/index.html","permalink":"http://engravesunny.github.io/categories/index.html","excerpt":"","text":"这里是分类哦"},{"title":"friends","date":"2022-10-08T12:01:56.000Z","updated":"2022-10-08T12:02:09.027Z","comments":true,"path":"friends/index.html","permalink":"http://engravesunny.github.io/friends/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-10-08T15:30:51.679Z","updated":"2022-10-08T15:30:51.679Z","comments":true,"path":"galleries/index.html","permalink":"http://engravesunny.github.io/galleries/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-10-08T12:01:13.000Z","updated":"2022-10-08T12:01:30.031Z","comments":true,"path":"contact/index.html","permalink":"http://engravesunny.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-10-08T11:58:37.000Z","updated":"2022-10-08T11:59:13.217Z","comments":true,"path":"tags/index.html","permalink":"http://engravesunny.github.io/tags/index.html","excerpt":"","text":""},{"title":"美图","date":"2022-10-09T08:54:45.910Z","updated":"2022-10-08T15:37:56.994Z","comments":true,"path":"galleries/美图/index.html","permalink":"http://engravesunny.github.io/galleries/%E7%BE%8E%E5%9B%BE/index.html","excerpt":"","text":""},{"title":"美图","date":"2022-10-09T08:54:28.957Z","updated":"2022-10-08T16:05:05.496Z","comments":true,"path":"galleries/动漫风景/index.html","permalink":"http://engravesunny.github.io/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"涩图","date":"2022-10-09T08:55:57.090Z","updated":"2022-10-09T08:55:57.090Z","comments":true,"path":"galleries/涩图/index.html","permalink":"http://engravesunny.github.io/galleries/%E6%B6%A9%E5%9B%BE/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2022-10-09T07:34:15.729Z","updated":"2022-10-09T07:34:15.729Z","comments":true,"path":"2022/10/09/hello-world/","link":"","permalink":"http://engravesunny.github.io/2022/10/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"10.1-3笔记","slug":"10.1-3笔记","date":"2022-10-09T01:25:00.000Z","updated":"2022-10-09T08:30:29.275Z","comments":true,"path":"2022/10/09/10.1-3-bi-ji/","link":"","permalink":"http://engravesunny.github.io/2022/10/09/10.1-3-bi-ji/","excerpt":"","text":"从今天开始学习React了！！（2022.10.01）jsx语法规则 1.定义虚拟DOM时，不要用引号 2.标签中混用JS表达式时要用&#123;&#125; 3.样式的类名指定不要用class，要用className 4.内联样式，要用style=&#123;&#123;key:value&#125;&#125;的形式去写 5.只有一个跟标签 6.标签必须闭合 7.标签首字母 (1).若小写字母开头，则将该标签转为html中同名元素，若html中没有该标签，就报错 (2).如果是大写字母开头，React就去渲染这个组件，没有定义的话就报错 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;style> .pink&amp;#123; background-color: pink; &amp;#125; &lt;/style> &lt;/head> &lt;body> &lt;div id=\"test\">&lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;script type=\"text/babel\"> /* 此处一定要写babel */ //1.创建虚拟DOM const x = '外部定义的变量' const id = 'title' const VDOM = ( &lt;div> &lt;h1 id=&amp;#123;id&amp;#125; className=\"pink\" style=&amp;#123;&amp;#123;color:'white'&amp;#125;&amp;#125;>Hello,React&lt;/h1> &lt;span>&amp;#123;x&amp;#125;&lt;/span> &lt;/div> ) //此处一定不要写引号，因为不是字符串 //2.渲染虚拟DOM到页面 // ReactDOM.render(虚拟DOM,容器) ReactDOM.render(VDOM,document.getElementById('test')) &lt;/script> &lt;/body> &lt;/html> 2.state属性组件内定义state属性&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;!-- 先准备好一个容器 --> &lt;div id=\"test\"> &lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;script type=\"text/babel\"> //创建一个组件 class Wether extends React.Component&amp;#123; constructor(props)&amp;#123; super(props) this.state=&amp;#123; isHot:false, wind:'大风' &amp;#125; &amp;#125; render()&amp;#123; return &lt;h1>今天天气很&amp;#123;this.state.isHot?'炎热':'凉爽'&amp;#125;,今天有&amp;#123;this.state.wind&amp;#125;&lt;/h1> &amp;#125; &amp;#125; ReactDOM.render(&lt;Wether/>,document.getElementById('test')) &lt;/script> &lt;/body> &lt;/html> state事件绑定&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;!-- 先准备好一个容器 --> &lt;div id=\"test\"> &lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;script type=\"text/babel\"> //创建一个组件 class Wether extends React.Component&amp;#123; // 构造器调用1次 constructor(props)&amp;#123; console.log('constructor'); super(props) this.state=&amp;#123; isHot:false, wind:'大风' &amp;#125; //解决clickFn中this指向问题 this.clickFn=this.clickFn.bind(this) &amp;#125; // render调用1+n次 1是初始化那次，n是状态更新的次数 render()&amp;#123; return &lt;h1 onClick=&amp;#123;this.clickFn&amp;#125;>今天天气很&amp;#123;this.state.isHot?'炎热':'凉爽'&amp;#125;,今天有&amp;#123;this.state.wind&amp;#125;&lt;/h1> &amp;#125; // 类内定义函数 clickFn()&amp;#123; // clickFn放在了Weather的原型对象上，供示例使用 // 由于clickFn是作为onClick的回调，所以不是通过实例调用的，是直接调用 // 类中的方法默认开启严格模式，所以clickFn中的this为undefined let isHot = this.state.isHot // 严重注意：状态(state)不可以直接修改，下面这行就是直接更改！！！ // this.state.isHot = !isHot console.log(this); // 严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换 this.setState(&amp;#123;isHot:!isHot&amp;#125;) &amp;#125; &amp;#125; ReactDOM.render(&lt;Wether/>,document.getElementById('test')) // 类外定义函数 // let clickFn = function()&amp;#123; // alert('被点击了') // &amp;#125; // console.log(clickFn); // let clickFn = ()=>&amp;#123; // alert('被点击了') // &amp;#125; // console.log(clickFn); // 测试了一下，上面两种方式没办法执行，不知道是jsx的问题还是我哪里的知识点落下了 —_— // function clickFn()&amp;#123; // alert('h1被点击了') // &amp;#125; // //上面这种是可以的 &lt;/script> &lt;/body> &lt;/html> state简写&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;!-- 先准备好一个容器 --> &lt;div id=\"test\">&lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;script type=\"text/babel\"> //创建一个组件 class Wether extends React.Component&amp;#123; //直接放到实例自身上 state=&amp;#123; isHot:false, wind:'大风' &amp;#125; // render调用1+n次 1是初始化那次，n是状态更新的次数 render()&amp;#123; return &lt;h1 onClick=&amp;#123;this.clickFn&amp;#125;>今天天气很&amp;#123;this.state.isHot?'炎热':'凉爽'&amp;#125;,今天有&amp;#123;this.state.wind&amp;#125;&lt;/h1> &amp;#125; // 自定义方法——要用赋值语句的形式+箭头函数 clickFn = ()=> &amp;#123; let isHot = this.state.isHot console.log(this); this.setState(&amp;#123;isHot:!isHot&amp;#125;) &amp;#125; &amp;#125; ReactDOM.render(&lt;Wether/>,document.getElementById('test')) &lt;/script> &lt;/body> &lt;/html> state总结1.state是组件对象最重要的属性，值是对象2.通过更新组件的state来更新对应的页面显示 注意1.组件中的render方法中的this为组件实例对象2.组件自定义方法中的this为undefined，如何解决？ 1)强制绑定this：通过函数对象的bind() 2)箭头函数3.状态数据，不能直接修改或更新 props属性props基本使用&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;div id=\"test1\">&lt;/div> &lt;div id=\"test2\">&lt;/div> &lt;div id=\"test3\">&lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;!-- prop-types库 --> &lt;script src=\"https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js\">&lt;/script> &lt;script type=\"text/babel\"> class Person extends React.Component&amp;#123; render()&amp;#123; const &amp;#123;name,age,sex&amp;#125; = this.props return &lt;ul> &lt;li>姓名：&amp;#123;name&amp;#125;&lt;/li> &lt;li>年龄：&amp;#123;age&amp;#125;&lt;/li> &lt;li>性别：&amp;#123;sex&amp;#125;&lt;/li> &lt;/ul> &amp;#125; &amp;#125; //对标签属性进行类型，必要性的限制 Person.propTypes = &amp;#123; name:PropTypes.string.isRequired, sex:PropTypes.string, age:PropTypes.number, speak:PropTypes.func &amp;#125; // 指定默认标签属性值 Person.defaultProps = &amp;#123; sex:'不男不女' &amp;#125; ReactDOM.render(&lt;Person name='jerry' age=&amp;#123;19&amp;#125; />,document.getElementById('test1')) ReactDOM.render(&lt;Person name='tom' age=&amp;#123;18&amp;#125; sex='男' />,document.getElementById('test2')) //批量传递标签属性 const p = &amp;#123;name:'jane' ,age:19, sex:'女' &amp;#125; ReactDOM.render(&lt;Person &amp;#123;...p&amp;#125; />,document.getElementById('test3')) &lt;/script> &lt;/body> &lt;/html> props的简写方法&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;div id=\"test1\">&lt;/div> &lt;div id=\"test2\">&lt;/div> &lt;div id=\"test3\">&lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;!-- prop-types库 --> &lt;script src=\"https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js\">&lt;/script> &lt;script type=\"text/babel\"> class Person extends React.Component&amp;#123; //对标签属性进行类型，必要性的限制 static propTypes = &amp;#123; name:PropTypes.string.isRequired, sex:PropTypes.string, age:PropTypes.number, speak:PropTypes.func &amp;#125; // 指定默认标签属性值 static defaultProps = &amp;#123; sex:'不男不女' &amp;#125; render()&amp;#123; const &amp;#123;name,age,sex&amp;#125; = this.props return &lt;ul> &lt;li>姓名：&amp;#123;name&amp;#125;&lt;/li> &lt;li>年龄：&amp;#123;age&amp;#125;&lt;/li> &lt;li>性别：&amp;#123;sex&amp;#125;&lt;/li> &lt;/ul> &amp;#125; &amp;#125; ReactDOM.render(&lt;Person name='jerry' age=&amp;#123;19&amp;#125; />,document.getElementById('test1')) ReactDOM.render(&lt;Person name='tom' age=&amp;#123;18&amp;#125; sex='男' />,document.getElementById('test2')) //批量传递标签属性 const p = &amp;#123;name:'jane' ,age:19, sex:'女' &amp;#125; ReactDOM.render(&lt;Person &amp;#123;...p&amp;#125; />,document.getElementById('test3')) &lt;/script> &lt;/body> &lt;/html>","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Alicia"},{"title":"10.4(props)笔记","slug":"10.4笔记","date":"2022-10-09T01:25:00.000Z","updated":"2022-10-09T08:30:38.322Z","comments":true,"path":"2022/10/09/10.4-bi-ji/","link":"","permalink":"http://engravesunny.github.io/2022/10/09/10.4-bi-ji/","excerpt":"","text":"props(继续学习)类式组件的构造器与props构造函数一般用在两种情况: 1.通过给this.state赋值对象来初始化内部state 2.为事件处理函数绑定实例 constructor(props)&amp;#123; super(props) //初始化state this.state=&amp;#123;isHot:true,wind:'微风'&amp;#125; // 解决 this 指向问题 this.changeWeather = this.changeWeather.bind(this) &amp;#125; 因此构造器一般不需要写，如果要在构造器内使用this.props才声明构造器,并且需要在最开始调用super(props) constructor(props)&amp;#123; super(props) console.log(this.props); &amp;#125; 函数式组件与props由于函数可以传递参数，因此函数式组件可以使用 props 。 &lt;script src=\"https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js\">&lt;/script> &lt;script type=\"text/babel\"> // 因为函数可以传参数，因此函数式组件可以使用props function Person(props)&amp;#123; const &amp;#123; name, age, sex &amp;#125; = props return ( &lt;ul> &lt;li>姓名：&amp;#123; name &amp;#125;&lt;/li> &lt;li>年龄：&amp;#123; age &amp;#125;&lt;/li> &lt;li>性别：&amp;#123; sex &amp;#125; &lt;/li> &lt;/ul> ) &amp;#125; Person.propTypes = &amp;#123; name:PropTypes.string.isRequired, age:PropTypes.number, sex:PropTypes.string, &amp;#125; Person.defaultProps = &amp;#123; sex:'男', age:18 &amp;#125; ReactDOM.render(&lt;Person name=\"tom\"/>,document.getElementById('test')) &lt;/script> 组件实例核心属性3–ref字符串类型的ref这种形式已过时，效率不高，官方不建议使用 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; showLeft = ()=> &amp;#123; const &amp;#123;ipt1&amp;#125; = this.refs alert(ipt1.value) &amp;#125; showRight = ()=> &amp;#123; const &amp;#123;ipt2&amp;#125; = this.refs alert(ipt2.value) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;input ref='ipt1' type=\"text\" placeholder=\"点我提示左侧信息\"/> &lt;button onClick=&amp;#123;this.showLeft&amp;#125;>点我提示左侧信息&lt;/button> &lt;input onBlur=&amp;#123;this.showRight&amp;#125; ref='ipt2' type=\"text\" placeholder=\"失去焦点提示右侧信息\"/> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 回调类型的ref要点： c =&gt; this.ipt1 = c就是给组件实例添加ipt1属性，值为节点 由于是箭头函数，因此this是render函数里的实例，即为组件实例 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; showLeft=()=>&amp;#123; const &amp;#123;ipt1&amp;#125; = this alert(ipt1.value) &amp;#125; showRight=()=>&amp;#123; const &amp;#123;ipt2&amp;#125; = this alert(ipt2.value) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;input ref=&amp;#123;c=>this.ipt1=c&amp;#125; type=\"text\" placeholder='点击获取左侧信息' /> &lt;button onClick=&amp;#123;this.showLeft&amp;#125;>点我获取左侧信息&lt;/button> &lt;input onBlur=&amp;#123;this.showRight&amp;#125; ref=&amp;#123;c=>this.ipt2=c&amp;#125; type=\"text\" placeholder='失去焦点提示右侧信息'/> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 关于回调 ref 执行次数的问题，官网 (opens new window)描述： TIP如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。 即内联函数形式，在更新过程中 ref 回调会被执行两次，第一次传入 null ，第二次传入 DOM 元素。若是下述形式，则只执行一次。但是对功能实现没有影响，因此一般也是用内联函数形式。 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; state=&amp;#123; isHot:true &amp;#125; changeWeather = ()=>&amp;#123; const isHot = this.state.isHot this.setState(&amp;#123;isHot:!isHot&amp;#125;) &amp;#125; showMsg = ()=>&amp;#123; const &amp;#123;ipt&amp;#125; = this alert(ipt.value) &amp;#125; saveRefs = (c)=>&amp;#123; &amp;#125; render()&amp;#123; const &amp;#123;isHot&amp;#125; = this.state return ( &lt;div> &lt;h2>&amp;#123;isHot?'炎热':'凉爽'&amp;#125;&lt;/h2> &amp;#123;/*&lt;input ref=&amp;#123;c=>&amp;#123;this.ipt=c;console.log('@',c)&amp;#125;&amp;#125; type=\"text\"/> &lt;br/>&lt;br/>*/&amp;#125; //上面回调在render更新渲染时会调用两次 //解决：外层定义一个save函数，ref回调里调用save，save里提取真实DOM &lt;input ref=&amp;#123;this.saveRefs&amp;#125; type=\"text\"/> &lt;br/>&lt;br/> &lt;button onClick=&amp;#123;this.showMsg&amp;#125;>点我提示信息&lt;/button> &lt;button onClick=&amp;#123;this.changeWeather&amp;#125;>切换&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> createRef API该方式通过调用React.CreateRef返回一个容器用于储存节点，且一个容器只能存储一个节点 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; myRef = React.createRef() showMsg = ()=>&amp;#123; console.log(this.myRef.current.value); &amp;#125; render()&amp;#123; return ( &lt;div> &lt;input ref=&amp;#123;this.myRef&amp;#125; type=\"text\"/> &lt;button onClick=&amp;#123;this.showMsg&amp;#125;>点击提示信息&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 事件处理 React 使用自定义事件，而非原生 DOM 事件，即 onClick、onBlur ：为了更好的兼容性 React 的事件通过事件委托方式进行处理：为了高效 通过 event.target 可获取触发事件的DOM元素：勿过度使用 ref 当触发事件的元素和需要操作的元素为同一元素时，可以不使用ref: class Demo extends React.Component &amp;#123; showData2 = (event) => &amp;#123; alert(event.target.value) &amp;#125; render() &amp;#123; return ( &lt;div> &lt;input onBlur=&amp;#123;this.showData2&amp;#125; type=\"text\" placeholder=\"失去焦点提示数据\" /> &amp;nbsp; &lt;/div> ) &amp;#125; &amp;#125;","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Alicia"},{"title":"10.5(React脚手架)","slug":"10.5(2)","date":"2022-10-08T08:00:44.726Z","updated":"2022-10-09T08:31:48.382Z","comments":true,"path":"2022/10/08/10.5-2/","link":"","permalink":"http://engravesunny.github.io/2022/10/08/10.5-2/","excerpt":"","text":"React脚手架React脚手架项目结构public:静态资源文件 manifest.json:应用加壳(把网页变成安卓&#x2F;ios软件)的配置文件 robots.txt:爬虫协议文件 src:源码文件 App.test.js:用于给App组件做测试 index.js:入口文件 reportWebVitals.js:页面性能分析文件，需要web-vitals支持 setupTests.js:组件单元测试文件，需要jest-dom支持 index.js代码分析: &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\" /> &lt;!-- %PUBLIC_URL% 代表 public 文件夹的路径 --> &lt;link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" /> &lt;!-- 开启理想视口，用于做移动端网页的适配 --> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> &lt;!-- 用于配置浏览器页签+地址栏的颜色(仅支持安卓手机浏览器) --> &lt;meta name=\"theme-color\" content=\"red\" /> &lt;!-- 网站描述 --> &lt;meta name=\"description\" content=\"Web site created using create-react-app\" /> &lt;!-- 用于指定网页添加到手机主屏幕后的图标 --> &lt;link rel=\"apple-touch-icon\" href=\"%PUBLIC_URL%/logo192.png\" /> &lt;!-- 应用加壳时的配置文件 --> &lt;link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" /> &lt;title>React App&lt;/title> &lt;/head> &lt;body> &lt;!-- 若浏览器不支持 js 则展示标签中的内容 --> &lt;noscript>You need to enable JavaScript to run this app.&lt;/noscript> &lt;div id=\"root\">&lt;/div> &lt;/body> &lt;/html> 样式的模块化样式的模块化可用于解决样式冲突的问题。该方法比较麻烦，实际开发用的比较少。用 less 就能解决了。component/Hello文件下的index.css改名为index.module.css .title&amp;#123; background-color:pink; &amp;#125; Hello组件导入样式: import &amp;#123; Component &amp;#125; from 'react' import hello from './index.module.css' export default class Hello extends Component &amp;#123; render() &amp;#123; return &lt;h2 className=&amp;#123;hello.title&amp;#125;>Hello,React!&lt;/h2> &amp;#125; &amp;#125; React网络请求React脚手架配置代理方法一： 在package.json文件中进行配置: \"proxy\":\"http://localhost:5000\" //要访问的url 优点：配置简单，前端请求资源不加前缀 缺点：不能配置多个代理 工作方式：当请求了3000端口（本机）不存在的资源时，就会把请求转发给5000端口号服务器 方法二： 在src目录下创建代理配置文件setupProxy.js，进行配置： const proxy = require('http-proxy-middleware') module.exports = function (app) &amp;#123; app.use( //api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000) proxy('/api1', &amp;#123; //配置转发目标地址(能返回数据的服务器地址) target: 'http://localhost:5000', //控制服务器接收到的请求头中host字段的值 /* changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000 changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000 changeOrigin默认值为false，但一般将changeOrigin改为true */ changeOrigin: true, //去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置) pathRewrite: &amp;#123; '^/api1': '' &amp;#125;, &amp;#125;), proxy('/api2', &amp;#123; target: 'http://localhost:5001', changeOrigin: true, pathRewrite: &amp;#123; '^/api2': '' &amp;#125;, &amp;#125;) ) &amp;#125;","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"10.7(React路由)","slug":"10.7","date":"2022-10-08T08:00:15.418Z","updated":"2022-10-09T08:32:00.421Z","comments":true,"path":"2022/10/08/10.7/","link":"","permalink":"http://engravesunny.github.io/2022/10/08/10.7/","excerpt":"","text":"React路由路由的严格匹配与模糊匹配 默认使用模糊匹配（输入路径必须包含要匹配的路径，且顺序一致 开启严格模式：&lt;Route exact path=&#39;/about&#39; component=&#123;About&#125;/&gt; 严格匹配开启可能会导致无法继续匹配二级路由 Redirect的使用 一般写在所有路由注册的最下方，当所有路由无法匹配时，跳转到Redirect指定的路由 &lt;Switch> &lt;Route path=\"/about\" component=\"&amp;#123;About&amp;#125;\" /> &lt;Route path=\"/home\" component=\"&amp;#123;Home&amp;#125;\" /> &lt;Redirect to=\"/about\" /> &lt;/Switch> 嵌套路由 注册子路由上需要写父路由的path 路由的匹配是按照注册路由的顺序进行的 &lt;!-- 父组件 --> &lt;MyNavLink to=\"/about\">About&lt;/MyNavLink> &lt;MyNavLink to=\"/home\">Home&lt;/MyNavLink> &lt;Switch> &lt;Route path=\"/about\" component=\"&amp;#123;About&amp;#125;\" /> &lt;Route path=\"/home\" component=\"&amp;#123;Home&amp;#125;\" /> &lt;Redirect to=\"/about\" /> &lt;/Switch> &lt;!-- 子组件 --> &lt;ul className=\"nav nav-tabs\"> &lt;li> &lt;MyNavLink to=\"/home/news\">News&lt;/MyNavLink> &lt;/li> &lt;li> &lt;MyNavLink to=\"/home/message\">Message&lt;/MyNavLink> &lt;/li> &lt;/ul> &lt;Switch> &lt;Route path=\"/home/news\" component=\"&amp;#123;News&amp;#125;\" /> &lt;Route path=\"/home/message\" component=\"&amp;#123;Message&amp;#125;\" /> &lt;Redirect to=\"/home/news\" /> &lt;/Switch> 路由传参三种方式：params,search,state三种方式对比： state:在当前页面刷新可以保留参数，但在新页面刷新不能保留。前两种方式因为是在url地址上保存参数，因此地址都能保留 params和search参数都会变成字符串 &lt;!-- 路由链接 --> &lt;Link to='/home/message/detail/Bruce/21'>params&lt;/Link> &lt;Link to=&amp;#123;`/home/message/detail/$&amp;#123;item.name&amp;#125;/$&amp;#123;item.age&amp;#125;`&amp;#125;>&amp;#123;item.name&amp;#125;&lt;/Link> &lt;Link to='/home/message/detail/?name=Bruce&amp;age=21'>search&lt;/Link> &lt;Link to=&amp;#123;`/home/message/detail/?id=$&amp;#123;item.name&amp;#125;&amp;title=$&amp;#123;item.age&amp;#125;`&amp;#125;>&amp;#123;item.name&amp;#125;&lt;/Link> &lt;Link to=&amp;#123;&amp;#123;pathname: '/home/message/detail', state: &amp;#123;name: 'Bruce', age: 21&amp;#125;&amp;#125;&amp;#125;>state&lt;/Link> &lt;!-- 注册路由 --> &lt;Route path='/home/message/detail/:name/:age' component=&amp;#123;Detail&amp;#125; /> &lt;!-- search 和 state 按正常注册即可 --> &lt;Route path='/home/message/detail' component=&amp;#123;Detail&amp;#125; /> //接收参数 const &amp;#123; name, age &amp;#125; = this.props.match.params import qs from 'querystring' const &amp;#123; search &amp;#125; = this.props.location const &amp;#123; name, age &amp;#125; = qs.parse(search.slice(1)) const &amp;#123; name, age &amp;#125; = this.props.location.state 编程式导航编程式导航是使用路由组件this.props.history提供的API进行路由跳转 this.props.history.push(path,state) this.props.history.replace(path,state) this.props.history.goForward() this.props.history.gopBack() this.props.history.go(2)参数为负数时是后退 //编程式导航传参数 this.props.history.push(`/home/message/detail/$&amp;#123;id&amp;#125;/$&amp;#123;title&amp;#125;`)//params传参 this.props.history.push(`/home/message/detail?id=&amp;#123;id&amp;#125;&amp;title=&amp;#123;title&amp;#125;`)//search传参 this.props.history.push(`/home/message/detail`,&amp;#123;id,title&amp;#125;)//state传参 withRouter的使用withRouter的作用：加工一般组件，使其像路由组件一样有路由组件的API，如this.props.history等。 import React,&amp;#123;Component&amp;#125; from 'react' import &amp;#123;withRouter&amp;#125; from 'react-router-dom' class Header extends Component&amp;#123; ... &amp;#125; export default withRouter(Header) BrowserRouter和HashRouter底层原理不一样 BrowserRouter使用的是H5的history API，不兼容IE9及以下版本 HashRouter使用的是URL的哈希值 路径表现不一样 BrowserRouter的路径中没有#，如：localhost:3000&#x2F;demo&#x2F;test HashRouter的路径包含#，如：localhost:3000&#x2F;demo&#x2F;test 刷新会对路由state参数的影响 BrowserRouter没有影响，因为state保存在history对象中 HashRouter刷新后会导致路由state参数的丢失 备注:HashRouter可以解决一些路径错误相关的问题 React UI 组件库Ant Design 配置按需引入和自定义主题以下配置是 3.x 版本，4.x 版本见官网 1.安装依赖： npm install react-app-rewired customize-cra babel-plugin-import less less-loader 2.修改 package.json \"scripts\": &amp;#123; \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\", \"eject\": \"react-scripts eject\" &amp;#125; 3.根目录下创建 config-overrides.js //配置具体的修改规则 const &amp;#123; override, fixBabelImports, addLessLoader &amp;#125; = require('customize-cra') module.exports = override( fixBabelImports('import', &amp;#123; libraryName: 'antd', libraryDirectory: 'es', style: true, &amp;#125;), addLessLoader(&amp;#123; lessOptions: &amp;#123; javascriptEnabled: true, modifyVars: &amp;#123; '@primary-color': 'green' &amp;#125;, &amp;#125;, &amp;#125;) ) 备注：不用在组件里引入样式，import ‘antd&#x2F;dist&#x2F;antd.css’ 删掉","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"10.6(Github案例总结)","slug":"10.6","date":"2022-10-08T08:00:15.406Z","updated":"2022-10-09T08:31:55.013Z","comments":true,"path":"2022/10/08/10.6/","link":"","permalink":"http://engravesunny.github.io/2022/10/08/10.6/","excerpt":"","text":"Github搜索框案例知识点总结 设计状态时要考虑全面，例如带有网络请求的组件，要考虑请求失败怎么办 ES6知识点：解构赋值+重命名 let obj = &amp;#123; a: &amp;#123; b: 1 &amp;#125; &amp;#125; //传统解构赋值 const &amp;#123; a &amp;#125; = obj //连续解构赋值 const &amp;#123; a: &amp;#123; b &amp;#125;, &amp;#125; = obj //连续解构赋值 + 重命名 const &amp;#123; a: &amp;#123; b: value &amp;#125;, &amp;#125; = obj 初始代码Search组件import React, &amp;#123; Component &amp;#125; from 'react' import axios from 'axios'; import './index.css' export default class Search extends Component &amp;#123; search = ()=>&amp;#123; //获取用户的输入 console.log(this.keyWord.value); const keyword = this.keyWord.value this.props.updateState(&amp;#123;isFirst:false,isLoading:true&amp;#125;) //发送网络请求 axios.get(`https://api.github.com/search/users?q=$&amp;#123;keyword&amp;#125;`).then( res =>&amp;#123; this.props.updateState(&amp;#123;users:res.data.items,isLoading:false&amp;#125;) &amp;#125;, err =>&amp;#123; this.props.updateState(&amp;#123;isLoading:false,err:err.message&amp;#125;) &amp;#125; ) &amp;#125; render() &amp;#123; return ( &lt;div className='search'> &lt;h1>Search Github Users&lt;/h1> &lt;input ref=&amp;#123;c=>this.keyWord=c&amp;#125; type=\"text\"/> &lt;button onClick=&amp;#123;this.search&amp;#125;>搜索&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; List组件import React, &amp;#123; Component &amp;#125; from 'react' import './Index.css' export default class List extends Component &amp;#123; render() &amp;#123; const &amp;#123;users,isFirst,isLoading,err&amp;#125; = this.props return ( &lt;div> &lt;ul> &amp;#123; isFirst ? &lt;h2>欢迎使用，输入关键字开始搜索&lt;/h2>: isLoading ? &lt;h2>Loading-------&lt;/h2>: err ? &lt;h2 style=&amp;#123;&amp;#123;color:'red'&amp;#125;&amp;#125;>&amp;#123;err&amp;#125;&lt;/h2>: users.map(item=>&amp;#123; return ( &lt;li key=&amp;#123;item.id&amp;#125;> &lt;a rel='noreferrer' href=&amp;#123;item.html_url&amp;#125; target='_blank'> &lt;img src=&amp;#123;item.avatar_url&amp;#125; alt=\"head_portrait\"/> &lt;p>&amp;#123;item.login&amp;#125;&lt;/p> &lt;/a> &lt;/li> ) &amp;#125;) &amp;#125; &lt;/ul> &lt;/div> ) &amp;#125; &amp;#125; App.jsimport React, &amp;#123; Component &amp;#125; from 'react'; import Search from './components/Search'; import List from './components/List'; export default class App extends Component &amp;#123; state = &amp;#123; users:[], isFirst:true, isLoading:false, err:'' &amp;#125; updateState = (stateObj)=>&amp;#123; this.setState(stateObj) &amp;#125; render() &amp;#123; return ( &lt;div> &lt;Search updateState=&amp;#123;this.updateState&amp;#125;>&lt;/Search> &lt;List &amp;#123;...this.state&amp;#125;>&lt;/List> &lt;/div> ); &amp;#125; &amp;#125; 3. 消息订阅与发布 限定月，再发布 适用于任意组件间通信 要在componentWillUnmount中取消订阅 使用PubSub代码Search组件(pubsub)import React, &amp;#123; Component &amp;#125; from 'react' import axios from 'axios'; import PubSub from 'pubsub-js'; import './index.css' export default class Search extends Component &amp;#123; search = ()=>&amp;#123; //获取用户的输入 console.log(this.keyWord.value); const keyword = this.keyWord.value // this.props.updateState(&amp;#123;isFirst:false,isLoading:true&amp;#125;) PubSub.publish('updateState',&amp;#123;isFirst:false,isLoading:true&amp;#125;) //发送网络请求 axios.get(`https://api.github.com/search/users?q=$&amp;#123;keyword&amp;#125;`).then( res =>&amp;#123; // this.props.updateState(&amp;#123;users:res.data.items,isLoading:false&amp;#125;) PubSub.publish('updateState',&amp;#123;users:res.data.items,isLoading:false&amp;#125;) &amp;#125;, err =>&amp;#123; // this.props.updateState(&amp;#123;isLoading:false,err:err.message&amp;#125;) PubSub.publish('updateState',&amp;#123;isLoading:false,err:err.message&amp;#125;) &amp;#125; ) &amp;#125; render() &amp;#123; return ( &lt;div className='search'> &lt;h1>Search Github Users&lt;/h1> &lt;input ref=&amp;#123;c=>this.keyWord=c&amp;#125; type=\"text\"/> &lt;button onClick=&amp;#123;this.search&amp;#125;>搜索&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; List组件(pubsub)import React, &amp;#123; Component &amp;#125; from 'react' import PubSub from 'pubsub-js' import './Index.css' export default class List extends Component &amp;#123; state = &amp;#123; users:[], isFirst:true, isLoading:false, err:'' &amp;#125; componentDidMount()&amp;#123; this.token = PubSub.subscribe('updateState',(_,data)=>&amp;#123; console.log(data); this.setState(data) &amp;#125;) &amp;#125; componentWillUnmount()&amp;#123; PubSub.unsubscribe(this.token) &amp;#125; render() &amp;#123; const &amp;#123;users,isFirst,isLoading,err&amp;#125; = this.state return ( &lt;div> &lt;ul> &amp;#123; isFirst ? &lt;h2>欢迎使用，输入关键字开始搜索&lt;/h2>: isLoading ? &lt;h2>Loading-------&lt;/h2>: err ? &lt;h2 style=&amp;#123;&amp;#123;color:'red'&amp;#125;&amp;#125;>&amp;#123;err&amp;#125;&lt;/h2>: users.map(item=>&amp;#123; return ( &lt;li key=&amp;#123;item.id&amp;#125;> &lt;a rel='noreferrer' href=&amp;#123;item.html_url&amp;#125; target='_blank'> &lt;img src=&amp;#123;item.avatar_url&amp;#125; alt=\"head_portrait\"/> &lt;p>&amp;#123;item.login&amp;#125;&lt;/p> &lt;/a> &lt;/li> ) &amp;#125;) &amp;#125; &lt;/ul> &lt;/div> ) &amp;#125; &amp;#125; App.js(pubsub)import React, &amp;#123; Component &amp;#125; from 'react'; import Search from './components/Search'; import List from './components/List'; export default class App extends Component &amp;#123; render() &amp;#123; return ( &lt;div> &lt;Search>&lt;/Search> &lt;List>&lt;/List> &lt;/div> ); &amp;#125; &amp;#125; 4.fetch发送请求(关注分离的设计思想) try &amp;#123; //先看看服务器能不能连上 const response = await fetch(`https://api.github.com/search/users?q=$&amp;#123;keyword&amp;#125;`) //在获取数据 const data = await response.json() PubSub.publish('updateState',&amp;#123;users:data.items,isLoading:false&amp;#125;) console.log(data); &amp;#125; catch (error) &amp;#123; console.log('请求出错',error); PubSub.publish('updateState',&amp;#123;isLoading:false,err:error.message&amp;#125;) &amp;#125; React 路由路由的理解何为路由 一个路由是一个映射关系 key 为路径，value 可能是 function 或 组件 后端路由： value 是 function ，用于处理客户端的请求 注册路由：router.get(path, function(req, res)) 工作过程：Node 接收到请求，根据路径匹配路由，调用对应函数处理请求，返回响应数据 前端路由： value 是组件 注册路由：&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt; 工作过程：浏览器路径变为/test ，展示 Test 组件 路由的基本使用导航区用&lt;Link&gt;,展示区用&lt;Route&gt; import React, &amp;#123; Component &amp;#125; from 'react'; import &amp;#123; Link , Route &amp;#125; from 'react-router-dom'; import Home from './components/Home' import About from './components/About' import './index.css' export default class App extends Component &amp;#123; render() &amp;#123; return ( &lt;div> &lt;div className=\"header\"> &lt;h1>React Router Demo&lt;/h1> &lt;/div> &lt;div className=\"native\"> &amp;#123;/* &lt;a href=\"#\">About&lt;/a> &lt;a href=\"#\">Home&lt;/a> */&amp;#125; &lt;div className=\"linkArea\"> &lt;Link className='link1 active' to=\"/about\">About&lt;/Link> &lt;Link className='link2' to=\"/home\">Home&lt;/Link> &lt;/div> &lt;/div> &lt;div className=\"view\"> &lt;Route path=\"/about\" component=&amp;#123;About&amp;#125; /> &lt;Route path=\"/home\" component=&amp;#123;Home&amp;#125; /> &lt;/div> &lt;/div> ); &amp;#125; &amp;#125; &lt;App&gt;最外侧包裹&lt;BrowserRouter&gt;或&lt;HashRouter&gt;: import React from \"react\"; import ReactDOM from \"react-dom\"; import &amp;#123; BrowserRouter &amp;#125; from \"react-router-dom\"; import App from \"./App\"; ReactDOM.render( &lt;BrowserRouter>&lt;App>&lt;/App>&lt;/BrowserRouter>, document.getElementById('root')) 路由组件和一般组件1.写法不同： 一般组件：&lt;Demo/&gt; 路由组件：&lt;Route path=&quot;/demo&quot; component=&#123;Demo&#125;/&gt; 2.存放位置不同： 一般组件：components 路由组件：pages 3.接收到的props不同： 一般组件：标签属性传递 路由组件：接收到三个固定的属性 history: go: ƒ go(n) goBack: ƒ goBack() goForward: ƒ goForward() push: ƒ push(path, state) replace: ƒ replace(path, state) location: pathname: \"/home/message/detail/2/hello\" search: \"\" state: undefined match: params: &amp;#123;&amp;#125; path: \"/home/message/detail/:id/:title\" url: \"/home/message/detail/2/hello\" NavLinkNavLink可以实现由链接的高亮，通过activeCassName指定样式名，默认追加类名为active &lt;NavLink activeClassName=\"demo\" to=\"/about\">About&lt;/NavLink> &lt;NavLink activeClassName=\"demo\" to=\"/home\">Home&lt;/NavLink> 封装NavLink组件:由于NavLink组件中的重复代码太多，因此进行二次封装※ 细节点：组件标签的内容会传递到 this.props.children属性中，反过来通过指定标签的 children 属性可以修改组件标签内容 // MyNavLink 组件 import React, &amp;#123; Component &amp;#125; from 'react' import &amp;#123; NavLink &amp;#125; from 'react-router-dom' export default class MyNavLink extends Component &amp;#123; render() &amp;#123; // this.props.children 可以取到标签内容，如 About, Home // 反过来通过指定标签的 children 属性可以修改标签内容 return &lt;NavLink activeClassName=\"demo\" className=\"list-group-item\" &amp;#123;...this.props&amp;#125; /> &amp;#125; &amp;#125; &lt;MyNavLink to=\"/about\">About&lt;/MyNavLink> &lt;MyNavLink to=\"/home\">Home&lt;/MyNavLink> Switch 的使用Switch可以提高路由匹配效率，如果匹配成功，则不再继续匹配后面的路由，即为单一匹配 &lt;Switch> &lt;Route path='/about' component=&amp;#123;About&amp;#125;/> &lt;Route path='/home' component=&amp;#123;Home&amp;#125;/> &lt;Route path='/home' component=&amp;#123;Test&amp;#125;/> &lt;/Switch> 解决多级路径刷新页面样式丢失的问题 public/index.html 中引入样式时不写./写/（常用） public/index.html中引入样式时不写./写%PUBLIC_URL%（常用） 使用HashRouter &lt;link rel=\"stylesheet\" href=\"/css/bootstrap.css\" /> &lt;link rel=\"stylesheet\" href=\"%PUBLIC_URL%/css/bootstrap.css\" />","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"10.5(受控非受控组件)","slug":"10.5","date":"2022-10-08T07:59:55.168Z","updated":"2022-10-09T08:31:40.321Z","comments":true,"path":"2022/10/08/10.5/","link":"","permalink":"http://engravesunny.github.io/2022/10/08/10.5/","excerpt":"","text":"受控 &amp; 非受控组件包含表单的组件分类： 非受控组件：现用现取。即需要时使用，再获取节点得到数据 受控组件：类似于Vue双向绑定的从视图层绑定到数据 尽量使用受控组件，因为非受控组件要使用大量的ref //非受控组件 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; handleSubmit = (event)=>&amp;#123; event.preventDefault(); const &amp;#123;username,password&amp;#125; = this alert( `您的用户名为$&amp;#123;username.value&amp;#125;，密码为$&amp;#123;password.value&amp;#125;` ) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;form onSubmit=&amp;#123; this.handleSubmit &amp;#125;> 用户名：&lt;input ref=&amp;#123;c=>this.username=c&amp;#125; type=\"text\" name='username'/>&lt;br/> 密码 ：&lt;input ref=&amp;#123;c=>this.password=c&amp;#125; type=\"password\" name='password'/>&lt;br/> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render( &lt;Demo>&lt;/Demo>,document.getElementById('test') ) &lt;/script> //受控组件 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; state = &amp;#123; username:'', password:'' &amp;#125; saveUserName = (event)=> &amp;#123; this.setState(&amp;#123;username:event.target.value&amp;#125;) &amp;#125; savePassword = (event)=> &amp;#123; this.setState(&amp;#123;password:event.target.value&amp;#125;) &amp;#125; handleSubmit = (event)=> &amp;#123; event.preventDefault(); const &amp;#123;username,password&amp;#125; = this.state; alert( `您的用户名为$&amp;#123; username &amp;#125;,密码为$&amp;#123; password &amp;#125;` ) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;form onSubmit=&amp;#123;this.handleSubmit&amp;#125;> &lt;input onChange=&amp;#123;this.saveUserName&amp;#125; type=\"text\"/> &lt;input onChange=&amp;#123;this.savePassword&amp;#125; type=\"password\"/> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 高阶函数_函数柯里化对上述受控组件代码进行优化，希望把saveUserName和savePassword合并为一个函数要点： 高阶函数：参数为函数或者返回一个函数的函数，如Promise、setTimeout、Array.map() 函数柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式 //函数柯里化 function sum(a)&amp;#123; return (b)=>&amp;#123; return (c)&amp;#123; return a + b + c; &amp;#125; &amp;#125; &amp;#125; //使用高阶函数和函数柯里化 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; state = &amp;#123; username:'', password:'' &amp;#125; saveFormData = (dataType)=>&amp;#123; return (event)=>&amp;#123; this.setState(&amp;#123;[dataType]:event.target.value&amp;#125;) &amp;#125; &amp;#125; handleSubmit = (event)=> &amp;#123; event.preventDefault(); const &amp;#123;username,password&amp;#125; = this.state; alert( `您的用户名为$&amp;#123; username &amp;#125;,密码为$&amp;#123; password &amp;#125;` ) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;form onSubmit=&amp;#123;this.handleSubmit&amp;#125;> &lt;input onChange=&amp;#123;this.saveFormData('username')&amp;#125; type=\"text\"/> &lt;input onChange=&amp;#123;this.saveFormData('password')&amp;#125; type=\"password\"/> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> //不使用柯里化写法 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; state = &amp;#123; username:'', password:'' &amp;#125; saveFormData = (dataType,event)=>&amp;#123; this.setState(&amp;#123;[dataType]:event.target.value&amp;#125;) &amp;#125; handleSubmit = (event)=> &amp;#123; event.preventDefault(); const &amp;#123;username,password&amp;#125; = this.state; alert( `您的用户名为$&amp;#123; username &amp;#125;,密码为$&amp;#123; password &amp;#125;` ) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;form onSubmit=&amp;#123;this.handleSubmit&amp;#125;> &lt;input onChange=&amp;#123;event=>this.saveFormData('username',event)&amp;#125; type=\"text\"/> &lt;input onChange=&amp;#123;event=>this.saveFormData('password',event)&amp;#125; type=\"password\"/> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 生命周期生命周期旧版初始化阶段：ReactDOM.render()触发的初次渲染 constructor componentWillMount render componentDidMount &#x3D;&#x3D;&#x3D;&gt; 常用 一般在这个钩子中做一些初始化的事：如：开启定时器，发送网络请求，订阅消息 更新阶段： 1.父组件重新render触发的更新 componentWillReceiveProps shouldComponentUpdate ：控制组件是否更新的阀门，返回值为布尔值，默认为true。若返回 false ，则后续流程不会进行。 componentWillUpdate render componentDidUpdate 2.组件内部调用this.setState()修改状态 shouldComponentUpdate componentWillUpdate render componentDidUpdate 3.组件内部调用this.forceUpdate()强制更新 componentWillUpdate render componentDidUpdate &#x3D;&#x3D;&#x3D;&gt; 常用 一般在这个钩子里做一些收尾的事，例如：关闭定时器，取消订阅消息 卸载阶段:ReactDOM.unmountComponentAtNode()触发 componentWillUnmount 生命周期新版更改内容 废弃三个钩子：componentWillMount、componentWillReceiveProps、componentWillUpdate。在新版本中这三个钩子需要加UNSAFE_前缀，后续可能会废弃 新增两个钩子（实际场景用的很少）：getDerivedStateFromProps、getSnapshotBeforeUpdate static getDerivedStateFromProps(props, state)： 需使用 static 修饰 需返回一个对象更新 state或返回 null 适用于如下情况：state 的值任何时候都取决于prop getSnapshotBeforeUpdate(prevProps, prevState)： 在组件更新之前获取快照 得组件能在发生更改之前从 DOM中捕获一些信息（如滚动位置） 返回值将作为参数传递给 componentDidUpdate() static getDerivedStateFromProps(props,state)&amp;#123; console.log('getDerivedStateFromProps',props,state); return null &amp;#125; getSnapshotBeforeUpdate()&amp;#123; console.log('getSnapshotBeforeUpdate'); return 'atguigu' &amp;#125; componentDidUpdate(preProps,preState,snapshotValue)&amp;#123; console.log('componentDidUpdate',preProps,preState,snapshotValue); &amp;#125; 最重要的三个钩子 render ：初始化渲染和更新渲染 componentDidMount ：进行初始化，如开启定时器、发送网络请求、订阅消息 componentWillUnmount ：进行收尾，如关闭定时器、取消订阅消息 虚拟 DOM 与 Diff 算法 key的作用key 是虚拟 DOM 对象的标识，可提高页面更新渲染的效率。 当状态中的数据发生变化时，React 会根据新数据生成新的虚拟 DOM ，接着对新旧虚拟 DOM 进行 Diff 比较，规则如下： 旧虚拟 DOM 找到和新虚拟 DOM 相同的 key： 若内容没变，直接复用真实 DOM 若内容改变，则生成新的真实 DOM ，替换页面中之前的真实 DOM 旧虚拟 DOM 未找到和新虚拟 DOM 相同的 key：根据数据创建新的真实 DOM ，渲染到页面 使用 index 作为 key 可能引发的问题： 若对数据进行逆序添加、逆序删除等破坏顺序的操作，会进行没有必要的真实 DOM 更新。界面效果没问题，但效率低下。 如果结构中包含输入类的 DOM（如 input 输入框） ，则会产生错误的 DOM 更新。 若不存在对数据逆序添加、逆序删除等破坏顺序的操作，则没有问题。","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}],"categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}