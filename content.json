{"meta":{"title":"刻猫猫的笔记本","subtitle":"目标是星辰与大海","description":"用来记录每天的学习内容","author":"AliciaChi","url":"http://engravesunny.github.io","root":"/"},"pages":[{"title":"about","date":"2022-10-08T12:00:36.000Z","updated":"2022-10-08T15:14:03.377Z","comments":true,"path":"about/index.html","permalink":"http://engravesunny.github.io/about/index.html","excerpt":"","text":"在source&#x2F;about下写简历"},{"title":"contact","date":"2022-10-08T12:01:13.000Z","updated":"2022-10-08T12:01:30.031Z","comments":true,"path":"contact/index.html","permalink":"http://engravesunny.github.io/contact/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-10-08T11:59:55.000Z","updated":"2022-10-09T08:29:57.952Z","comments":true,"path":"categories/index.html","permalink":"http://engravesunny.github.io/categories/index.html","excerpt":"","text":"这里是分类哦"},{"title":"追番","date":"2022-10-09T09:27:16.573Z","updated":"2022-10-09T09:27:16.573Z","comments":true,"path":"bangumis/index.html","permalink":"http://engravesunny.github.io/bangumis/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-10-08T12:01:56.000Z","updated":"2022-10-08T12:02:09.027Z","comments":true,"path":"friends/index.html","permalink":"http://engravesunny.github.io/friends/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-10-08T15:30:51.679Z","updated":"2022-10-08T15:30:51.679Z","comments":true,"path":"galleries/index.html","permalink":"http://engravesunny.github.io/galleries/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-10-08T11:58:37.000Z","updated":"2022-10-08T11:59:13.217Z","comments":true,"path":"tags/index.html","permalink":"http://engravesunny.github.io/tags/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-10-10T14:23:26.167Z","updated":"2022-10-10T14:23:26.167Z","comments":true,"path":"galleries/动漫风景/index.html","permalink":"http://engravesunny.github.io/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"美图","date":"2022-10-09T08:54:45.910Z","updated":"2022-10-08T15:37:56.994Z","comments":true,"path":"galleries/美图/index.html","permalink":"http://engravesunny.github.io/galleries/%E7%BE%8E%E5%9B%BE/index.html","excerpt":"","text":""},{"title":"涩图","date":"2022-10-09T08:55:57.090Z","updated":"2022-10-09T08:55:57.090Z","comments":true,"path":"galleries/涩图/index.html","permalink":"http://engravesunny.github.io/galleries/%E6%B6%A9%E5%9B%BE/index.html","excerpt":"","text":""}],"posts":[{"title":"redux学习笔记","slug":"10.10redux笔记","date":"2022-10-10T13:23:53.000Z","updated":"2022-10-10T14:08:34.383Z","comments":true,"path":"2022/10/10/10.10redux-bi-ji/","link":"","permalink":"http://engravesunny.github.io/2022/10/10/10.10redux-bi-ji/","excerpt":"","text":"Redux概述Redux为何物 Redux是用于做状态管理的JS库 可用于React，Angular，Vue等项目中，常用于React 集中式管理React应用多个组件共享的状态 何时用Redux 某个组件的状态需要让其他组件拿到 一个组件要改变另一个组件的状态 使用原则：不到万不得已不要轻易使用 Redux 工作流程 组件想用Redux中的状态：把动作类型和数据告诉Action Creators Action Creators创建actions:同步action是一个普通对象，异步action是一个函数 Store调用dispatch()分发给Reducers执行 Reducers接收previousState,action两个参数，对状态进行加工后返回新状态 Store调用getState()把状态传给组件 核心概念action: 表示动作的对象，包含两个属性 type:表示属性，值为字符串，唯一，必须属性 data:数据属性，类型任意，可选属性 {type:’string’,data:data} reducer: 用于初始化状态、加工状态 根据旧状态和action产生新状态 是纯函数 纯函数：输入同样的实参，必定得到同样的输出 不能改写参数数据 不产生副作用，如网络请求、输入输出设备（网络请求不稳定） 不能调用 Date.now() 、Math.random() 等不纯方法 store: Redux核心对象，内部维护着state和reducer 核心API store.getState():获取状态 store.dispatch(action):分发任务，触发reducer调用，产生新状态 store.subscribe(func):注册监听函数，当状态改变自动调用 一个求和案例// App.jsx import React, &amp;#123; Component &amp;#125; from 'react' import Count from './components/Count' export default class App extends Component &amp;#123; render() &amp;#123; return ( &lt;div> &lt;Count /> &lt;/div> ) &amp;#125; &amp;#125; // index.js import React from 'react' import ReactDOM from 'react-dom' import App from './App' import store from './redux/store' ReactDOM.render(&lt;App />, document.getElementById('root')) // 状态改变重新渲染 App 组件 store.subscribe(() => &amp;#123; ReactDOM.render(&lt;App />, document.getElementById('root')) &amp;#125;) // redux/constant.js // 保存常量值 export const INCREMENT = 'increment' export const DECREMENT = 'decrement' // redux/count_reducer.js import &amp;#123; INCREMENT, DECREMENT &amp;#125; from './constant' //初始化状态 const initState = 0 export default function countReducer(preState = initState, action) &amp;#123; const &amp;#123; type, data &amp;#125; = action switch (type) &amp;#123; case INCREMENT: return preState + data case DECREMENT: return preState - data default: return preState &amp;#125; &amp;#125; // redux/store.js import &amp;#123; createStore &amp;#125; from 'redux' //引入为 Count 组件服务的 reducer import countReducer from './count_reducer' export default createStore(countReducer) // redux/count_action.js import &amp;#123; INCREMENT, DECREMENT &amp;#125; from './constant' export const createIncrementAction = (data) => (&amp;#123; type: INCREMENT, data &amp;#125;) export const createDecrementAction = (data) => (&amp;#123; type: DECREMENT, data &amp;#125;) // components/Count/index.jsx import React, &amp;#123; Component &amp;#125; from 'react' import store from '../../redux/store' import &amp;#123; createIncrementAction, createDecrementAction &amp;#125; from '../../redux/count_action' export default class Count extends Component &amp;#123; // 可在组件单独监听 Redux 状态变化 // componentDidMount() &amp;#123; // store.subscribe(() => &amp;#123; // this.setState(&amp;#123;&amp;#125;) // &amp;#125;) // &amp;#125; increment = () => &amp;#123; const &amp;#123; value &amp;#125; = this.selectNumber // 将 value 转为数值 // 手动写 Action 对象 store.dispatch(&amp;#123; type: 'increment', data: value * 1 &amp;#125;) // 专门创建 Action 对象 store.dispatch(createIncrementAction(value * 1)) &amp;#125; decrement = () => &amp;#123; const &amp;#123; value &amp;#125; = this.selectNumber store.dispatch(createDecrementAction(value * 1)) &amp;#125; incrementAsync = () => &amp;#123; const &amp;#123; value &amp;#125; = this.selectNumber setTimeout(() => &amp;#123; store.dispatch(createIncrementAction(value * 1)) &amp;#125;, 500) &amp;#125; render() &amp;#123; return ( &lt;div> &lt;h1>当前求和为：&amp;#123;store.getState()&amp;#125;&lt;/h1> &lt;select ref=&amp;#123;(c) => (this.selectNumber = c)&amp;#125;> &lt;option value=\"1\">1&lt;/option> &lt;option value=\"2\">2&lt;/option> &lt;option value=\"3\">3&lt;/option> &lt;/select> &lt;button onClick=&amp;#123;this.increment&amp;#125;>+&lt;/button> &lt;button onClick=&amp;#123;this.decrement&amp;#125;>-&lt;/button> &lt;button onClick=&amp;#123;this.incrementAsync&amp;#125;>异步加&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; Redux只负责管理状态，状态改变后页面的更新需要自己写 可以在index.js中监听状态变化，不能直接调render(),要用this.setState(&#123;&#125;)间接调用 reducer由store首次调用时传递的previousState是undefined，action为&#123;type:&#39;@@REDUX/INIT_a.5.v.9&#39;&#125;类似的东西，没有传data Redux异步编程安装异步中间件： npm install redux-thunk -S 要点： 延迟的动作不想交给组件，而是 action 当操作状态所需数据要靠异步任务返回时，可用异步 action 创建 action 的函数返回一个函数，该函数中写异步任务 异步任务完成后，分发一个同步 action 操作状态 异步 action 不是必要的，完全可以在组件中等待异步任务结果返回在分发同步 action // store.js import &amp;#123; createStore, applyMiddleware &amp;#125; from 'redux' import countReducer from './count_reducer' import thunk from 'redux-thunk' export default createStore(countReducer, applyMiddleware(thunk)) // count_action.js import &amp;#123; INCREMENT, DECREMENT &amp;#125; from './constant.js' export const createIncrementAction = (data) => (&amp;#123; type: INCREMENT, data &amp;#125;) export const createDecrementAction = (data) => (&amp;#123; type: DECREMENT, data &amp;#125;) // 异步 action 返回一个函数 export const createIncrementAsyncAction = (data, time) => &amp;#123; return (dispatch) => &amp;#123; setTimeout(() => &amp;#123; dispatch(createIncrementAction(data)) &amp;#125;, time) &amp;#125; &amp;#125; // Count.jsx incrementAsync = () => &amp;#123; const &amp;#123; value &amp;#125; = this.selectNumber store.dispatch(createIncrementAsyncAction(value * 1)) &amp;#125; 整个过程简单理解：store 在分发 action 时，发现返回一个函数，那它知道这是个异步 action 。因此 store 勉为其难地帮忙执行这个函数，同时给这个函数传递 dispatch 方法，等待异步任务完成取到数据后，直接调用 dispatch 方法分发同步 action 。","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"hexo博客主题与修改","slug":"hexo博客主题安装与修改","date":"2022-10-09T14:52:23.000Z","updated":"2022-10-09T15:44:33.089Z","comments":true,"path":"2022/10/09/hexo-bo-ke-zhu-ti-an-zhuang-yu-xiu-gai/","link":"","permalink":"http://engravesunny.github.io/2022/10/09/hexo-bo-ke-zhu-ti-an-zhuang-yu-xiu-gai/","excerpt":"","text":"hexo博客主题安装与修改1.主题下载与安装点击下载地址下载master分支的最新稳定版的代码，解压缩后，将hexo-theme-matery的文件复制到hexo的theme文件夹中即可 当然你也可以在你的站点目录文件夹下使用 git clone 命令来下载：直接在站点根目录下执行下面的命令，即可进行主题的下载，主题有两个版本，稳定版本和最新版本(不定期更新优化)，自主选择版本。 git clone https://github.com/blinkfox/hexo-theme-matery themes/matery # 稳定版 git clone -b develop https://github.com/blinkfox/hexo-theme-matery themes/matery #最新版(不定期进行优化更新) 2.主题配置2.1 切换主题 进入根目录下的_config.yml中，往下滑到大概101行有一个theme，将它改为刚才你引入到根目录theme下的文件夹的名字就行，记得theme:后加一个空格即theme: 你引入的文件夹的名字（不用加引号） 语言选择：如果为中文用户，则在language:后添加值zh-CN，如果不修改，默认为英语；网址修改：url:的值为你的网址名，如http://xxxx.github.io，如果有域名，则修改为你的域名即可点配置文件有个per_page属性，建议修改为6的倍数，这样网站在适应设备时，有较好的显示效果。 2.2 新建页面 本次操作需要新建’tags’,’categories’,’about’,’contact’(留言板（可选）),’friends’(友情链接(可选))基本操作都是一样以’tags’为例 tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags&#x2F;index.md 文件，那么你就需要新建一个，命令如下 hexo new page \"tags\" 编辑你刚刚新建的页面文件 &#x2F;source&#x2F;tags&#x2F;index.md，至少需要以下内容： --- title: tags date: 2018-09-30 18:23:38 type: &quot;tags&quot; layout: &quot;tags&quot; --- 其他页面的新建也是如此，将tags改为对应的就行，如about，把上面的tags都改为about就行 tags和category用法你新建玩tags和category页面以后 在你写post中的md文件时在顶部加入以下代码 title: 10.5(React脚手架) categories: React tags: - React - 笔记 就会生成以下效果 新建friend页面后同时，在你的博客source目录下新建_data目录，在_data目录中新建friends.json文件，文件内容如下所示： [&amp;#123; \"avatar\": \"../avatars/1.jpg\", \"name\": \"灰色的小伊\", \"introduction\": \"来bilibili了解更多追番，冲冲冲\", \"url\": \"https://space.bilibili.com/244375982?spm_id_from=333.1007.0.0\", \"title\": \"前去学习\" &amp;#125;, &amp;#123; \"avatar\": \"../avatars/0.png\", \"name\": \"太阳\", \"introduction\": \"更多知识笔记，来语雀一起学习\", \"url\": \"https://www.yuque.com/dashboard/my_books\", \"title\": \"前去学习\" &amp;#125;, &amp;#123; \"avatar\": \"https://avatars.githubusercontent.com/u/100678707?v=4\", \"name\": \"engravesunny\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://github.com/Engravesunny\", \"title\": \"前去学习\" &amp;#125;] 2.3菜单导航配置 1.菜单导航名称可以是中文也可以是英文(如：Index或主页)2.图标icon 可以在Font Awesome 中查找 在你引入的主题文件夹中的_config.yml中更改以下代码 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book 以上是一级菜单二级菜单配置方法：1.在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children)2.在children下创建二级菜单的 名称name,路径url和图标icon.3.注意每个二级菜单模块前要加 -.4.注意缩进格式 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image 2.4代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下： npm i -S hexo-prism-plugin prism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: 2.5 搜索 本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： npm install hexo-generator-search --save search: path: search.xml field: post 2.6中文链接转拼音（可选的） 如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。 npm i hexo-permalink-pinyin --save permalink_pinyin: enable: true separator: &#39;-&#39; # default: &#39;-&#39; 注：除了此插件外，hexo-abbrlink 插件也可以生成非中文的链接。 2.7 文章字数统计插件（可选的） 如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。 安装命令如下： npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，激活以下配置项即可： wordCount: enable: false # 将这个值设置为 true 即可. postWordCount: true min2read: true totalCount: true 2.8 添加 DaoVoice 在线聊天功能（可选的） 前往 DaoVoice官网注册并且获取app_id，并将app_id填入主题的_config.yml 文件中 2.9 添加 Tidio 在线聊天功能（可选的） 前往 Tidio官网注册并且获取Public Key，并将Public Key填入主题的_config.yml 文件中。 2.10 修改页脚 页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 &#x2F;layout&#x2F;_partial&#x2F;footer.ejs 文件中，包括站点、使用的主题、访问量等。 2.11 修改社交链接 在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 &#x2F;layout&#x2F;_partial&#x2F;social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： &lt;% if (theme.socialLink.github) &amp;#123; %> &lt;a href=\"&lt;%= theme.socialLink.github %>\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\"> &lt;i class=\"fab fa-github\">&lt;/i> &lt;/a> &lt;% &amp;#125; %> 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebookTwitter: fab fa-twitterGoogle-plus: fab fa-google-plusLinkedin: fab fa-linkedinTumblr: fab fa-tumblrMedium: fab fa-mediumSlack: fab fa-slackSina Weibo: fab fa-weiboWechat: fab fa-weixinQQ: fab fa-qqZhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0 2.12 修改打赏的二维码图片 在主题文件的 source&#x2F;medias&#x2F;reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片.2.13 配置音乐播放器（可选的） 要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。 首先，在你的博客 source 目录下的 _data 目录（没有的话就新建一个）中新建 musics.json 文件，文件内容如下所示： [&amp;#123; \"name\": \"五月雨变奏电音\", \"artist\": \"AnimeVibe\", \"url\": \"http://xxx.com/music1.mp3\", \"cover\": \"http://xxx.com/music-cover1.png\" &amp;#125;, &amp;#123; \"name\": \"Take me hand\", \"artist\": \"DAISHI DANCE,Cecile Corbel\", \"url\": \"/medias/music/music2.mp3\", \"cover\": \"/medias/music/cover2.png\" &amp;#125;, &amp;#123; \"name\": \"Shape of You\", \"artist\": \"J.Fla\", \"url\": \"http://xxx.com/music3.mp3\", \"cover\": \"http://xxx.com/music-cover3.png\" &amp;#125;] 注：以上 JSON 中的属性：name、artist、url、cover 分别表示音乐的名称、作者、音乐文件地址、音乐封面 然后，在主题的 _config.yml 配置文件中激活配置即可： # 是否在首页显示音乐. music: enable: true showTitle: false title: 听听音乐 fixed: false # 是否开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'list' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: false # 列表默认折叠 listMaxHeight: # 列表最大高度 3.文章 Front-matter 介绍 Front-matter 选项详解 Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。 最简示例 --- title: typora-vue-theme主题介绍 date: 2018-09-07 09:25:00 --- 最全示例 --- title: typora-vue-theme主题介绍 date: 2022-05-02 09:25:00 author: CrazyYu img: /source/images/xxx.jpg top: true cover: true coverImg: /images/1.jpg password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Markdown tags: - Typora - Markdown --- 4.效果截图 最新版本进行了优化更新，效果图与最初的效果图有差别，下面的图不是最新版本的。 今天先到这，我也要洗澡睡觉了(23:44)","categories":[{"name":"博客修改","slug":"博客修改","permalink":"http://engravesunny.github.io/categories/%E5%8D%9A%E5%AE%A2%E4%BF%AE%E6%94%B9/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"博客修改","slug":"博客修改","permalink":"http://engravesunny.github.io/tags/%E5%8D%9A%E5%AE%A2%E4%BF%AE%E6%94%B9/"}]},{"title":"搭建hexo博客","slug":"10.8-10.9笔记","date":"2022-10-09T14:18:22.000Z","updated":"2022-10-09T14:51:00.800Z","comments":true,"path":"2022/10/09/10.8-10.9-bi-ji/","link":"","permalink":"http://engravesunny.github.io/2022/10/09/10.8-10.9-bi-ji/","excerpt":"","text":"简单博客搭建流程这两天主要就是在搭建和配置自己的小博客(以后会发一点博文，不过我大多会是笔记本来用) 本地安装以及发布 安装到本地 首先选择一个磁盘作为你博客文件的存放位置，然后新建一个文件夹，比如名为blogtest的文件夹，创建完后，先不要点进去，在此处点击鼠标右键，选择Git Bash Here，然后依次输入如下命令： # hexo框架的安装 npm install -g hexo-cli # 等上一个命令完成后，在输入下面的命令 hexo init &lt;新建文件夹的名称> #初始化文件夹 cd &lt;新建文件夹的名称> npm install # 安装博客所需要的依赖文件 等待运行完的时候，此时文件夹里多了很多文件注意：后续的命令都在站点目录下使用Git Bash运行此时Hexo框架的本地搭建已经完成了。命令行依次输入以下命令: hexo g hexo s 浏览器中打开它执行完后给你的地址（默认为http://localhost:4000/），可以看到一个网页，说明Hexo已经成功在本地运行 2.本地博客发布到Github Pages 首先安装可以用来发布的插件，在站点目录下执行以下命令: npm install hexo-deployer-git --save 然后把本地目录与GitHub关联起来，输入以下命令行: ssh-keygen -t rsa -C '你的邮箱地址' 然后一直回车找到C:&#x2F;Users&#x2F;[username]目录下名为.ssh的文件夹，文件夹内会有两个文件，一个id_rsa.pub一个id_rsa，用文本编辑器打开id_rsa.pub，复制里面的的内容。 然后打开Github，点击右上角的头像 Settings 选择SSH and GPG keys 点击New SSH key 将之前复制的内容粘帖到Key的框中。 上面的Title可以随意，点击Add SSH key 完成添加。 然后回到命令行界面，测试一下是否与github连接成功 ssh -T git@github.com 点击回车，然后会出现一个询问内容，输入yes，回车，会出现一段内容，Hi ! You’ve successfully authenticated, but GitHub doesnot provide shell access.。 说明连接成功。此处这个应该是你Github的用户名。 进入博客站点目录，用文本编辑器打开_config.yml，这个_config.yml是博客的配置文件，在以后的博客修改，如个性化修改，博客SEO优化等都会使用到， 修改如下图的几个地方： title: 你的博客名 subtitle: 博客的副标题，有些主题支持 description: 博客描述 keywords: 博客关键词 author: 作者，在文章中显示 language: 博客语言语种 timezone: 时区 滑到文件最底部，有一个deploy，在deploy下面添加一个repo项 ，一个branch项。填入如下代码，并如下图所示 type: git repo: git@github.com:Github用户名/github用户名.github.io.git //也可使用https地址，如：https://github.com/Github用户名/Github用户名.github.io.git branch: master 最后就是生成页面，并发布至Github Pages，执行如下命令： # Hexo会根据配置文件渲染出一套静态页面 hexo g # 将上一步渲染出的一系列文件上传至至Github Pages hexo d # 也可以直接输入此命令，直接完成渲染和上传 hexo g -d hexo博客主题的安装于修改会在另一篇里专门讲","categories":[{"name":"博客","slug":"博客","permalink":"http://engravesunny.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"博客","slug":"博客","permalink":"http://engravesunny.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-09T07:34:15.729Z","updated":"2022-10-09T07:34:15.729Z","comments":true,"path":"2022/10/09/hello-world/","link":"","permalink":"http://engravesunny.github.io/2022/10/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"10.1-3笔记","slug":"10.1-3笔记","date":"2022-10-09T01:25:00.000Z","updated":"2022-10-09T08:30:29.275Z","comments":true,"path":"2022/10/09/10.1-3-bi-ji/","link":"","permalink":"http://engravesunny.github.io/2022/10/09/10.1-3-bi-ji/","excerpt":"","text":"从今天开始学习React了！！（2022.10.01）jsx语法规则 1.定义虚拟DOM时，不要用引号 2.标签中混用JS表达式时要用&#123;&#125; 3.样式的类名指定不要用class，要用className 4.内联样式，要用style=&#123;&#123;key:value&#125;&#125;的形式去写 5.只有一个跟标签 6.标签必须闭合 7.标签首字母 (1).若小写字母开头，则将该标签转为html中同名元素，若html中没有该标签，就报错 (2).如果是大写字母开头，React就去渲染这个组件，没有定义的话就报错 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;style> .pink&amp;#123; background-color: pink; &amp;#125; &lt;/style> &lt;/head> &lt;body> &lt;div id=\"test\">&lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;script type=\"text/babel\"> /* 此处一定要写babel */ //1.创建虚拟DOM const x = '外部定义的变量' const id = 'title' const VDOM = ( &lt;div> &lt;h1 id=&amp;#123;id&amp;#125; className=\"pink\" style=&amp;#123;&amp;#123;color:'white'&amp;#125;&amp;#125;>Hello,React&lt;/h1> &lt;span>&amp;#123;x&amp;#125;&lt;/span> &lt;/div> ) //此处一定不要写引号，因为不是字符串 //2.渲染虚拟DOM到页面 // ReactDOM.render(虚拟DOM,容器) ReactDOM.render(VDOM,document.getElementById('test')) &lt;/script> &lt;/body> &lt;/html> 2.state属性组件内定义state属性&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;!-- 先准备好一个容器 --> &lt;div id=\"test\"> &lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;script type=\"text/babel\"> //创建一个组件 class Wether extends React.Component&amp;#123; constructor(props)&amp;#123; super(props) this.state=&amp;#123; isHot:false, wind:'大风' &amp;#125; &amp;#125; render()&amp;#123; return &lt;h1>今天天气很&amp;#123;this.state.isHot?'炎热':'凉爽'&amp;#125;,今天有&amp;#123;this.state.wind&amp;#125;&lt;/h1> &amp;#125; &amp;#125; ReactDOM.render(&lt;Wether/>,document.getElementById('test')) &lt;/script> &lt;/body> &lt;/html> state事件绑定&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;!-- 先准备好一个容器 --> &lt;div id=\"test\"> &lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;script type=\"text/babel\"> //创建一个组件 class Wether extends React.Component&amp;#123; // 构造器调用1次 constructor(props)&amp;#123; console.log('constructor'); super(props) this.state=&amp;#123; isHot:false, wind:'大风' &amp;#125; //解决clickFn中this指向问题 this.clickFn=this.clickFn.bind(this) &amp;#125; // render调用1+n次 1是初始化那次，n是状态更新的次数 render()&amp;#123; return &lt;h1 onClick=&amp;#123;this.clickFn&amp;#125;>今天天气很&amp;#123;this.state.isHot?'炎热':'凉爽'&amp;#125;,今天有&amp;#123;this.state.wind&amp;#125;&lt;/h1> &amp;#125; // 类内定义函数 clickFn()&amp;#123; // clickFn放在了Weather的原型对象上，供示例使用 // 由于clickFn是作为onClick的回调，所以不是通过实例调用的，是直接调用 // 类中的方法默认开启严格模式，所以clickFn中的this为undefined let isHot = this.state.isHot // 严重注意：状态(state)不可以直接修改，下面这行就是直接更改！！！ // this.state.isHot = !isHot console.log(this); // 严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换 this.setState(&amp;#123;isHot:!isHot&amp;#125;) &amp;#125; &amp;#125; ReactDOM.render(&lt;Wether/>,document.getElementById('test')) // 类外定义函数 // let clickFn = function()&amp;#123; // alert('被点击了') // &amp;#125; // console.log(clickFn); // let clickFn = ()=>&amp;#123; // alert('被点击了') // &amp;#125; // console.log(clickFn); // 测试了一下，上面两种方式没办法执行，不知道是jsx的问题还是我哪里的知识点落下了 —_— // function clickFn()&amp;#123; // alert('h1被点击了') // &amp;#125; // //上面这种是可以的 &lt;/script> &lt;/body> &lt;/html> state简写&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;!-- 先准备好一个容器 --> &lt;div id=\"test\">&lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;script type=\"text/babel\"> //创建一个组件 class Wether extends React.Component&amp;#123; //直接放到实例自身上 state=&amp;#123; isHot:false, wind:'大风' &amp;#125; // render调用1+n次 1是初始化那次，n是状态更新的次数 render()&amp;#123; return &lt;h1 onClick=&amp;#123;this.clickFn&amp;#125;>今天天气很&amp;#123;this.state.isHot?'炎热':'凉爽'&amp;#125;,今天有&amp;#123;this.state.wind&amp;#125;&lt;/h1> &amp;#125; // 自定义方法——要用赋值语句的形式+箭头函数 clickFn = ()=> &amp;#123; let isHot = this.state.isHot console.log(this); this.setState(&amp;#123;isHot:!isHot&amp;#125;) &amp;#125; &amp;#125; ReactDOM.render(&lt;Wether/>,document.getElementById('test')) &lt;/script> &lt;/body> &lt;/html> state总结1.state是组件对象最重要的属性，值是对象2.通过更新组件的state来更新对应的页面显示 注意1.组件中的render方法中的this为组件实例对象2.组件自定义方法中的this为undefined，如何解决？ 1)强制绑定this：通过函数对象的bind() 2)箭头函数3.状态数据，不能直接修改或更新 props属性props基本使用&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;div id=\"test1\">&lt;/div> &lt;div id=\"test2\">&lt;/div> &lt;div id=\"test3\">&lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;!-- prop-types库 --> &lt;script src=\"https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js\">&lt;/script> &lt;script type=\"text/babel\"> class Person extends React.Component&amp;#123; render()&amp;#123; const &amp;#123;name,age,sex&amp;#125; = this.props return &lt;ul> &lt;li>姓名：&amp;#123;name&amp;#125;&lt;/li> &lt;li>年龄：&amp;#123;age&amp;#125;&lt;/li> &lt;li>性别：&amp;#123;sex&amp;#125;&lt;/li> &lt;/ul> &amp;#125; &amp;#125; //对标签属性进行类型，必要性的限制 Person.propTypes = &amp;#123; name:PropTypes.string.isRequired, sex:PropTypes.string, age:PropTypes.number, speak:PropTypes.func &amp;#125; // 指定默认标签属性值 Person.defaultProps = &amp;#123; sex:'不男不女' &amp;#125; ReactDOM.render(&lt;Person name='jerry' age=&amp;#123;19&amp;#125; />,document.getElementById('test1')) ReactDOM.render(&lt;Person name='tom' age=&amp;#123;18&amp;#125; sex='男' />,document.getElementById('test2')) //批量传递标签属性 const p = &amp;#123;name:'jane' ,age:19, sex:'女' &amp;#125; ReactDOM.render(&lt;Person &amp;#123;...p&amp;#125; />,document.getElementById('test3')) &lt;/script> &lt;/body> &lt;/html> props的简写方法&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;div id=\"test1\">&lt;/div> &lt;div id=\"test2\">&lt;/div> &lt;div id=\"test3\">&lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;!-- prop-types库 --> &lt;script src=\"https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js\">&lt;/script> &lt;script type=\"text/babel\"> class Person extends React.Component&amp;#123; //对标签属性进行类型，必要性的限制 static propTypes = &amp;#123; name:PropTypes.string.isRequired, sex:PropTypes.string, age:PropTypes.number, speak:PropTypes.func &amp;#125; // 指定默认标签属性值 static defaultProps = &amp;#123; sex:'不男不女' &amp;#125; render()&amp;#123; const &amp;#123;name,age,sex&amp;#125; = this.props return &lt;ul> &lt;li>姓名：&amp;#123;name&amp;#125;&lt;/li> &lt;li>年龄：&amp;#123;age&amp;#125;&lt;/li> &lt;li>性别：&amp;#123;sex&amp;#125;&lt;/li> &lt;/ul> &amp;#125; &amp;#125; ReactDOM.render(&lt;Person name='jerry' age=&amp;#123;19&amp;#125; />,document.getElementById('test1')) ReactDOM.render(&lt;Person name='tom' age=&amp;#123;18&amp;#125; sex='男' />,document.getElementById('test2')) //批量传递标签属性 const p = &amp;#123;name:'jane' ,age:19, sex:'女' &amp;#125; ReactDOM.render(&lt;Person &amp;#123;...p&amp;#125; />,document.getElementById('test3')) &lt;/script> &lt;/body> &lt;/html>","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Alicia"},{"title":"10.4(props)笔记","slug":"10.4笔记","date":"2022-10-09T01:25:00.000Z","updated":"2022-10-09T08:30:38.322Z","comments":true,"path":"2022/10/09/10.4-bi-ji/","link":"","permalink":"http://engravesunny.github.io/2022/10/09/10.4-bi-ji/","excerpt":"","text":"props(继续学习)类式组件的构造器与props构造函数一般用在两种情况: 1.通过给this.state赋值对象来初始化内部state 2.为事件处理函数绑定实例 constructor(props)&amp;#123; super(props) //初始化state this.state=&amp;#123;isHot:true,wind:'微风'&amp;#125; // 解决 this 指向问题 this.changeWeather = this.changeWeather.bind(this) &amp;#125; 因此构造器一般不需要写，如果要在构造器内使用this.props才声明构造器,并且需要在最开始调用super(props) constructor(props)&amp;#123; super(props) console.log(this.props); &amp;#125; 函数式组件与props由于函数可以传递参数，因此函数式组件可以使用 props 。 &lt;script src=\"https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js\">&lt;/script> &lt;script type=\"text/babel\"> // 因为函数可以传参数，因此函数式组件可以使用props function Person(props)&amp;#123; const &amp;#123; name, age, sex &amp;#125; = props return ( &lt;ul> &lt;li>姓名：&amp;#123; name &amp;#125;&lt;/li> &lt;li>年龄：&amp;#123; age &amp;#125;&lt;/li> &lt;li>性别：&amp;#123; sex &amp;#125; &lt;/li> &lt;/ul> ) &amp;#125; Person.propTypes = &amp;#123; name:PropTypes.string.isRequired, age:PropTypes.number, sex:PropTypes.string, &amp;#125; Person.defaultProps = &amp;#123; sex:'男', age:18 &amp;#125; ReactDOM.render(&lt;Person name=\"tom\"/>,document.getElementById('test')) &lt;/script> 组件实例核心属性3–ref字符串类型的ref这种形式已过时，效率不高，官方不建议使用 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; showLeft = ()=> &amp;#123; const &amp;#123;ipt1&amp;#125; = this.refs alert(ipt1.value) &amp;#125; showRight = ()=> &amp;#123; const &amp;#123;ipt2&amp;#125; = this.refs alert(ipt2.value) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;input ref='ipt1' type=\"text\" placeholder=\"点我提示左侧信息\"/> &lt;button onClick=&amp;#123;this.showLeft&amp;#125;>点我提示左侧信息&lt;/button> &lt;input onBlur=&amp;#123;this.showRight&amp;#125; ref='ipt2' type=\"text\" placeholder=\"失去焦点提示右侧信息\"/> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 回调类型的ref要点： c =&gt; this.ipt1 = c就是给组件实例添加ipt1属性，值为节点 由于是箭头函数，因此this是render函数里的实例，即为组件实例 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; showLeft=()=>&amp;#123; const &amp;#123;ipt1&amp;#125; = this alert(ipt1.value) &amp;#125; showRight=()=>&amp;#123; const &amp;#123;ipt2&amp;#125; = this alert(ipt2.value) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;input ref=&amp;#123;c=>this.ipt1=c&amp;#125; type=\"text\" placeholder='点击获取左侧信息' /> &lt;button onClick=&amp;#123;this.showLeft&amp;#125;>点我获取左侧信息&lt;/button> &lt;input onBlur=&amp;#123;this.showRight&amp;#125; ref=&amp;#123;c=>this.ipt2=c&amp;#125; type=\"text\" placeholder='失去焦点提示右侧信息'/> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 关于回调 ref 执行次数的问题，官网 (opens new window)描述： TIP如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。 即内联函数形式，在更新过程中 ref 回调会被执行两次，第一次传入 null ，第二次传入 DOM 元素。若是下述形式，则只执行一次。但是对功能实现没有影响，因此一般也是用内联函数形式。 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; state=&amp;#123; isHot:true &amp;#125; changeWeather = ()=>&amp;#123; const isHot = this.state.isHot this.setState(&amp;#123;isHot:!isHot&amp;#125;) &amp;#125; showMsg = ()=>&amp;#123; const &amp;#123;ipt&amp;#125; = this alert(ipt.value) &amp;#125; saveRefs = (c)=>&amp;#123; &amp;#125; render()&amp;#123; const &amp;#123;isHot&amp;#125; = this.state return ( &lt;div> &lt;h2>&amp;#123;isHot?'炎热':'凉爽'&amp;#125;&lt;/h2> &amp;#123;/*&lt;input ref=&amp;#123;c=>&amp;#123;this.ipt=c;console.log('@',c)&amp;#125;&amp;#125; type=\"text\"/> &lt;br/>&lt;br/>*/&amp;#125; //上面回调在render更新渲染时会调用两次 //解决：外层定义一个save函数，ref回调里调用save，save里提取真实DOM &lt;input ref=&amp;#123;this.saveRefs&amp;#125; type=\"text\"/> &lt;br/>&lt;br/> &lt;button onClick=&amp;#123;this.showMsg&amp;#125;>点我提示信息&lt;/button> &lt;button onClick=&amp;#123;this.changeWeather&amp;#125;>切换&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> createRef API该方式通过调用React.CreateRef返回一个容器用于储存节点，且一个容器只能存储一个节点 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; myRef = React.createRef() showMsg = ()=>&amp;#123; console.log(this.myRef.current.value); &amp;#125; render()&amp;#123; return ( &lt;div> &lt;input ref=&amp;#123;this.myRef&amp;#125; type=\"text\"/> &lt;button onClick=&amp;#123;this.showMsg&amp;#125;>点击提示信息&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 事件处理 React 使用自定义事件，而非原生 DOM 事件，即 onClick、onBlur ：为了更好的兼容性 React 的事件通过事件委托方式进行处理：为了高效 通过 event.target 可获取触发事件的DOM元素：勿过度使用 ref 当触发事件的元素和需要操作的元素为同一元素时，可以不使用ref: class Demo extends React.Component &amp;#123; showData2 = (event) => &amp;#123; alert(event.target.value) &amp;#125; render() &amp;#123; return ( &lt;div> &lt;input onBlur=&amp;#123;this.showData2&amp;#125; type=\"text\" placeholder=\"失去焦点提示数据\" /> &amp;nbsp; &lt;/div> ) &amp;#125; &amp;#125;","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Alicia"},{"title":"10.5(React脚手架)","slug":"10.5(2)","date":"2022-10-08T08:00:44.726Z","updated":"2022-10-09T08:31:48.382Z","comments":true,"path":"2022/10/08/10.5-2/","link":"","permalink":"http://engravesunny.github.io/2022/10/08/10.5-2/","excerpt":"","text":"React脚手架React脚手架项目结构public:静态资源文件 manifest.json:应用加壳(把网页变成安卓&#x2F;ios软件)的配置文件 robots.txt:爬虫协议文件 src:源码文件 App.test.js:用于给App组件做测试 index.js:入口文件 reportWebVitals.js:页面性能分析文件，需要web-vitals支持 setupTests.js:组件单元测试文件，需要jest-dom支持 index.js代码分析: &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\" /> &lt;!-- %PUBLIC_URL% 代表 public 文件夹的路径 --> &lt;link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" /> &lt;!-- 开启理想视口，用于做移动端网页的适配 --> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> &lt;!-- 用于配置浏览器页签+地址栏的颜色(仅支持安卓手机浏览器) --> &lt;meta name=\"theme-color\" content=\"red\" /> &lt;!-- 网站描述 --> &lt;meta name=\"description\" content=\"Web site created using create-react-app\" /> &lt;!-- 用于指定网页添加到手机主屏幕后的图标 --> &lt;link rel=\"apple-touch-icon\" href=\"%PUBLIC_URL%/logo192.png\" /> &lt;!-- 应用加壳时的配置文件 --> &lt;link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" /> &lt;title>React App&lt;/title> &lt;/head> &lt;body> &lt;!-- 若浏览器不支持 js 则展示标签中的内容 --> &lt;noscript>You need to enable JavaScript to run this app.&lt;/noscript> &lt;div id=\"root\">&lt;/div> &lt;/body> &lt;/html> 样式的模块化样式的模块化可用于解决样式冲突的问题。该方法比较麻烦，实际开发用的比较少。用 less 就能解决了。component/Hello文件下的index.css改名为index.module.css .title&amp;#123; background-color:pink; &amp;#125; Hello组件导入样式: import &amp;#123; Component &amp;#125; from 'react' import hello from './index.module.css' export default class Hello extends Component &amp;#123; render() &amp;#123; return &lt;h2 className=&amp;#123;hello.title&amp;#125;>Hello,React!&lt;/h2> &amp;#125; &amp;#125; React网络请求React脚手架配置代理方法一： 在package.json文件中进行配置: \"proxy\":\"http://localhost:5000\" //要访问的url 优点：配置简单，前端请求资源不加前缀 缺点：不能配置多个代理 工作方式：当请求了3000端口（本机）不存在的资源时，就会把请求转发给5000端口号服务器 方法二： 在src目录下创建代理配置文件setupProxy.js，进行配置： const proxy = require('http-proxy-middleware') module.exports = function (app) &amp;#123; app.use( //api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000) proxy('/api1', &amp;#123; //配置转发目标地址(能返回数据的服务器地址) target: 'http://localhost:5000', //控制服务器接收到的请求头中host字段的值 /* changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000 changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000 changeOrigin默认值为false，但一般将changeOrigin改为true */ changeOrigin: true, //去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置) pathRewrite: &amp;#123; '^/api1': '' &amp;#125;, &amp;#125;), proxy('/api2', &amp;#123; target: 'http://localhost:5001', changeOrigin: true, pathRewrite: &amp;#123; '^/api2': '' &amp;#125;, &amp;#125;) ) &amp;#125;","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"10.7(React路由)","slug":"10.7","date":"2022-10-08T08:00:15.418Z","updated":"2022-10-09T08:32:00.421Z","comments":true,"path":"2022/10/08/10.7/","link":"","permalink":"http://engravesunny.github.io/2022/10/08/10.7/","excerpt":"","text":"React路由路由的严格匹配与模糊匹配 默认使用模糊匹配（输入路径必须包含要匹配的路径，且顺序一致 开启严格模式：&lt;Route exact path=&#39;/about&#39; component=&#123;About&#125;/&gt; 严格匹配开启可能会导致无法继续匹配二级路由 Redirect的使用 一般写在所有路由注册的最下方，当所有路由无法匹配时，跳转到Redirect指定的路由 &lt;Switch> &lt;Route path=\"/about\" component=\"&amp;#123;About&amp;#125;\" /> &lt;Route path=\"/home\" component=\"&amp;#123;Home&amp;#125;\" /> &lt;Redirect to=\"/about\" /> &lt;/Switch> 嵌套路由 注册子路由上需要写父路由的path 路由的匹配是按照注册路由的顺序进行的 &lt;!-- 父组件 --> &lt;MyNavLink to=\"/about\">About&lt;/MyNavLink> &lt;MyNavLink to=\"/home\">Home&lt;/MyNavLink> &lt;Switch> &lt;Route path=\"/about\" component=\"&amp;#123;About&amp;#125;\" /> &lt;Route path=\"/home\" component=\"&amp;#123;Home&amp;#125;\" /> &lt;Redirect to=\"/about\" /> &lt;/Switch> &lt;!-- 子组件 --> &lt;ul className=\"nav nav-tabs\"> &lt;li> &lt;MyNavLink to=\"/home/news\">News&lt;/MyNavLink> &lt;/li> &lt;li> &lt;MyNavLink to=\"/home/message\">Message&lt;/MyNavLink> &lt;/li> &lt;/ul> &lt;Switch> &lt;Route path=\"/home/news\" component=\"&amp;#123;News&amp;#125;\" /> &lt;Route path=\"/home/message\" component=\"&amp;#123;Message&amp;#125;\" /> &lt;Redirect to=\"/home/news\" /> &lt;/Switch> 路由传参三种方式：params,search,state三种方式对比： state:在当前页面刷新可以保留参数，但在新页面刷新不能保留。前两种方式因为是在url地址上保存参数，因此地址都能保留 params和search参数都会变成字符串 &lt;!-- 路由链接 --> &lt;Link to='/home/message/detail/Bruce/21'>params&lt;/Link> &lt;Link to=&amp;#123;`/home/message/detail/$&amp;#123;item.name&amp;#125;/$&amp;#123;item.age&amp;#125;`&amp;#125;>&amp;#123;item.name&amp;#125;&lt;/Link> &lt;Link to='/home/message/detail/?name=Bruce&amp;age=21'>search&lt;/Link> &lt;Link to=&amp;#123;`/home/message/detail/?id=$&amp;#123;item.name&amp;#125;&amp;title=$&amp;#123;item.age&amp;#125;`&amp;#125;>&amp;#123;item.name&amp;#125;&lt;/Link> &lt;Link to=&amp;#123;&amp;#123;pathname: '/home/message/detail', state: &amp;#123;name: 'Bruce', age: 21&amp;#125;&amp;#125;&amp;#125;>state&lt;/Link> &lt;!-- 注册路由 --> &lt;Route path='/home/message/detail/:name/:age' component=&amp;#123;Detail&amp;#125; /> &lt;!-- search 和 state 按正常注册即可 --> &lt;Route path='/home/message/detail' component=&amp;#123;Detail&amp;#125; /> //接收参数 const &amp;#123; name, age &amp;#125; = this.props.match.params import qs from 'querystring' const &amp;#123; search &amp;#125; = this.props.location const &amp;#123; name, age &amp;#125; = qs.parse(search.slice(1)) const &amp;#123; name, age &amp;#125; = this.props.location.state 编程式导航编程式导航是使用路由组件this.props.history提供的API进行路由跳转 this.props.history.push(path,state) this.props.history.replace(path,state) this.props.history.goForward() this.props.history.gopBack() this.props.history.go(2)参数为负数时是后退 //编程式导航传参数 this.props.history.push(`/home/message/detail/$&amp;#123;id&amp;#125;/$&amp;#123;title&amp;#125;`)//params传参 this.props.history.push(`/home/message/detail?id=&amp;#123;id&amp;#125;&amp;title=&amp;#123;title&amp;#125;`)//search传参 this.props.history.push(`/home/message/detail`,&amp;#123;id,title&amp;#125;)//state传参 withRouter的使用withRouter的作用：加工一般组件，使其像路由组件一样有路由组件的API，如this.props.history等。 import React,&amp;#123;Component&amp;#125; from 'react' import &amp;#123;withRouter&amp;#125; from 'react-router-dom' class Header extends Component&amp;#123; ... &amp;#125; export default withRouter(Header) BrowserRouter和HashRouter底层原理不一样 BrowserRouter使用的是H5的history API，不兼容IE9及以下版本 HashRouter使用的是URL的哈希值 路径表现不一样 BrowserRouter的路径中没有#，如：localhost:3000&#x2F;demo&#x2F;test HashRouter的路径包含#，如：localhost:3000&#x2F;demo&#x2F;test 刷新会对路由state参数的影响 BrowserRouter没有影响，因为state保存在history对象中 HashRouter刷新后会导致路由state参数的丢失 备注:HashRouter可以解决一些路径错误相关的问题 React UI 组件库Ant Design 配置按需引入和自定义主题以下配置是 3.x 版本，4.x 版本见官网 1.安装依赖： npm install react-app-rewired customize-cra babel-plugin-import less less-loader 2.修改 package.json \"scripts\": &amp;#123; \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\", \"eject\": \"react-scripts eject\" &amp;#125; 3.根目录下创建 config-overrides.js //配置具体的修改规则 const &amp;#123; override, fixBabelImports, addLessLoader &amp;#125; = require('customize-cra') module.exports = override( fixBabelImports('import', &amp;#123; libraryName: 'antd', libraryDirectory: 'es', style: true, &amp;#125;), addLessLoader(&amp;#123; lessOptions: &amp;#123; javascriptEnabled: true, modifyVars: &amp;#123; '@primary-color': 'green' &amp;#125;, &amp;#125;, &amp;#125;) ) 备注：不用在组件里引入样式，import ‘antd&#x2F;dist&#x2F;antd.css’ 删掉","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"10.6(Github案例总结)","slug":"10.6","date":"2022-10-08T08:00:15.406Z","updated":"2022-10-09T08:31:55.013Z","comments":true,"path":"2022/10/08/10.6/","link":"","permalink":"http://engravesunny.github.io/2022/10/08/10.6/","excerpt":"","text":"Github搜索框案例知识点总结 设计状态时要考虑全面，例如带有网络请求的组件，要考虑请求失败怎么办 ES6知识点：解构赋值+重命名 let obj = &amp;#123; a: &amp;#123; b: 1 &amp;#125; &amp;#125; //传统解构赋值 const &amp;#123; a &amp;#125; = obj //连续解构赋值 const &amp;#123; a: &amp;#123; b &amp;#125;, &amp;#125; = obj //连续解构赋值 + 重命名 const &amp;#123; a: &amp;#123; b: value &amp;#125;, &amp;#125; = obj 初始代码Search组件import React, &amp;#123; Component &amp;#125; from 'react' import axios from 'axios'; import './index.css' export default class Search extends Component &amp;#123; search = ()=>&amp;#123; //获取用户的输入 console.log(this.keyWord.value); const keyword = this.keyWord.value this.props.updateState(&amp;#123;isFirst:false,isLoading:true&amp;#125;) //发送网络请求 axios.get(`https://api.github.com/search/users?q=$&amp;#123;keyword&amp;#125;`).then( res =>&amp;#123; this.props.updateState(&amp;#123;users:res.data.items,isLoading:false&amp;#125;) &amp;#125;, err =>&amp;#123; this.props.updateState(&amp;#123;isLoading:false,err:err.message&amp;#125;) &amp;#125; ) &amp;#125; render() &amp;#123; return ( &lt;div className='search'> &lt;h1>Search Github Users&lt;/h1> &lt;input ref=&amp;#123;c=>this.keyWord=c&amp;#125; type=\"text\"/> &lt;button onClick=&amp;#123;this.search&amp;#125;>搜索&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; List组件import React, &amp;#123; Component &amp;#125; from 'react' import './Index.css' export default class List extends Component &amp;#123; render() &amp;#123; const &amp;#123;users,isFirst,isLoading,err&amp;#125; = this.props return ( &lt;div> &lt;ul> &amp;#123; isFirst ? &lt;h2>欢迎使用，输入关键字开始搜索&lt;/h2>: isLoading ? &lt;h2>Loading-------&lt;/h2>: err ? &lt;h2 style=&amp;#123;&amp;#123;color:'red'&amp;#125;&amp;#125;>&amp;#123;err&amp;#125;&lt;/h2>: users.map(item=>&amp;#123; return ( &lt;li key=&amp;#123;item.id&amp;#125;> &lt;a rel='noreferrer' href=&amp;#123;item.html_url&amp;#125; target='_blank'> &lt;img src=&amp;#123;item.avatar_url&amp;#125; alt=\"head_portrait\"/> &lt;p>&amp;#123;item.login&amp;#125;&lt;/p> &lt;/a> &lt;/li> ) &amp;#125;) &amp;#125; &lt;/ul> &lt;/div> ) &amp;#125; &amp;#125; App.jsimport React, &amp;#123; Component &amp;#125; from 'react'; import Search from './components/Search'; import List from './components/List'; export default class App extends Component &amp;#123; state = &amp;#123; users:[], isFirst:true, isLoading:false, err:'' &amp;#125; updateState = (stateObj)=>&amp;#123; this.setState(stateObj) &amp;#125; render() &amp;#123; return ( &lt;div> &lt;Search updateState=&amp;#123;this.updateState&amp;#125;>&lt;/Search> &lt;List &amp;#123;...this.state&amp;#125;>&lt;/List> &lt;/div> ); &amp;#125; &amp;#125; 3. 消息订阅与发布 限定月，再发布 适用于任意组件间通信 要在componentWillUnmount中取消订阅 使用PubSub代码Search组件(pubsub)import React, &amp;#123; Component &amp;#125; from 'react' import axios from 'axios'; import PubSub from 'pubsub-js'; import './index.css' export default class Search extends Component &amp;#123; search = ()=>&amp;#123; //获取用户的输入 console.log(this.keyWord.value); const keyword = this.keyWord.value // this.props.updateState(&amp;#123;isFirst:false,isLoading:true&amp;#125;) PubSub.publish('updateState',&amp;#123;isFirst:false,isLoading:true&amp;#125;) //发送网络请求 axios.get(`https://api.github.com/search/users?q=$&amp;#123;keyword&amp;#125;`).then( res =>&amp;#123; // this.props.updateState(&amp;#123;users:res.data.items,isLoading:false&amp;#125;) PubSub.publish('updateState',&amp;#123;users:res.data.items,isLoading:false&amp;#125;) &amp;#125;, err =>&amp;#123; // this.props.updateState(&amp;#123;isLoading:false,err:err.message&amp;#125;) PubSub.publish('updateState',&amp;#123;isLoading:false,err:err.message&amp;#125;) &amp;#125; ) &amp;#125; render() &amp;#123; return ( &lt;div className='search'> &lt;h1>Search Github Users&lt;/h1> &lt;input ref=&amp;#123;c=>this.keyWord=c&amp;#125; type=\"text\"/> &lt;button onClick=&amp;#123;this.search&amp;#125;>搜索&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; List组件(pubsub)import React, &amp;#123; Component &amp;#125; from 'react' import PubSub from 'pubsub-js' import './Index.css' export default class List extends Component &amp;#123; state = &amp;#123; users:[], isFirst:true, isLoading:false, err:'' &amp;#125; componentDidMount()&amp;#123; this.token = PubSub.subscribe('updateState',(_,data)=>&amp;#123; console.log(data); this.setState(data) &amp;#125;) &amp;#125; componentWillUnmount()&amp;#123; PubSub.unsubscribe(this.token) &amp;#125; render() &amp;#123; const &amp;#123;users,isFirst,isLoading,err&amp;#125; = this.state return ( &lt;div> &lt;ul> &amp;#123; isFirst ? &lt;h2>欢迎使用，输入关键字开始搜索&lt;/h2>: isLoading ? &lt;h2>Loading-------&lt;/h2>: err ? &lt;h2 style=&amp;#123;&amp;#123;color:'red'&amp;#125;&amp;#125;>&amp;#123;err&amp;#125;&lt;/h2>: users.map(item=>&amp;#123; return ( &lt;li key=&amp;#123;item.id&amp;#125;> &lt;a rel='noreferrer' href=&amp;#123;item.html_url&amp;#125; target='_blank'> &lt;img src=&amp;#123;item.avatar_url&amp;#125; alt=\"head_portrait\"/> &lt;p>&amp;#123;item.login&amp;#125;&lt;/p> &lt;/a> &lt;/li> ) &amp;#125;) &amp;#125; &lt;/ul> &lt;/div> ) &amp;#125; &amp;#125; App.js(pubsub)import React, &amp;#123; Component &amp;#125; from 'react'; import Search from './components/Search'; import List from './components/List'; export default class App extends Component &amp;#123; render() &amp;#123; return ( &lt;div> &lt;Search>&lt;/Search> &lt;List>&lt;/List> &lt;/div> ); &amp;#125; &amp;#125; 4.fetch发送请求(关注分离的设计思想) try &amp;#123; //先看看服务器能不能连上 const response = await fetch(`https://api.github.com/search/users?q=$&amp;#123;keyword&amp;#125;`) //在获取数据 const data = await response.json() PubSub.publish('updateState',&amp;#123;users:data.items,isLoading:false&amp;#125;) console.log(data); &amp;#125; catch (error) &amp;#123; console.log('请求出错',error); PubSub.publish('updateState',&amp;#123;isLoading:false,err:error.message&amp;#125;) &amp;#125; React 路由路由的理解何为路由 一个路由是一个映射关系 key 为路径，value 可能是 function 或 组件 后端路由： value 是 function ，用于处理客户端的请求 注册路由：router.get(path, function(req, res)) 工作过程：Node 接收到请求，根据路径匹配路由，调用对应函数处理请求，返回响应数据 前端路由： value 是组件 注册路由：&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt; 工作过程：浏览器路径变为/test ，展示 Test 组件 路由的基本使用导航区用&lt;Link&gt;,展示区用&lt;Route&gt; import React, &amp;#123; Component &amp;#125; from 'react'; import &amp;#123; Link , Route &amp;#125; from 'react-router-dom'; import Home from './components/Home' import About from './components/About' import './index.css' export default class App extends Component &amp;#123; render() &amp;#123; return ( &lt;div> &lt;div className=\"header\"> &lt;h1>React Router Demo&lt;/h1> &lt;/div> &lt;div className=\"native\"> &amp;#123;/* &lt;a href=\"#\">About&lt;/a> &lt;a href=\"#\">Home&lt;/a> */&amp;#125; &lt;div className=\"linkArea\"> &lt;Link className='link1 active' to=\"/about\">About&lt;/Link> &lt;Link className='link2' to=\"/home\">Home&lt;/Link> &lt;/div> &lt;/div> &lt;div className=\"view\"> &lt;Route path=\"/about\" component=&amp;#123;About&amp;#125; /> &lt;Route path=\"/home\" component=&amp;#123;Home&amp;#125; /> &lt;/div> &lt;/div> ); &amp;#125; &amp;#125; &lt;App&gt;最外侧包裹&lt;BrowserRouter&gt;或&lt;HashRouter&gt;: import React from \"react\"; import ReactDOM from \"react-dom\"; import &amp;#123; BrowserRouter &amp;#125; from \"react-router-dom\"; import App from \"./App\"; ReactDOM.render( &lt;BrowserRouter>&lt;App>&lt;/App>&lt;/BrowserRouter>, document.getElementById('root')) 路由组件和一般组件1.写法不同： 一般组件：&lt;Demo/&gt; 路由组件：&lt;Route path=&quot;/demo&quot; component=&#123;Demo&#125;/&gt; 2.存放位置不同： 一般组件：components 路由组件：pages 3.接收到的props不同： 一般组件：标签属性传递 路由组件：接收到三个固定的属性 history: go: ƒ go(n) goBack: ƒ goBack() goForward: ƒ goForward() push: ƒ push(path, state) replace: ƒ replace(path, state) location: pathname: \"/home/message/detail/2/hello\" search: \"\" state: undefined match: params: &amp;#123;&amp;#125; path: \"/home/message/detail/:id/:title\" url: \"/home/message/detail/2/hello\" NavLinkNavLink可以实现由链接的高亮，通过activeCassName指定样式名，默认追加类名为active &lt;NavLink activeClassName=\"demo\" to=\"/about\">About&lt;/NavLink> &lt;NavLink activeClassName=\"demo\" to=\"/home\">Home&lt;/NavLink> 封装NavLink组件:由于NavLink组件中的重复代码太多，因此进行二次封装※ 细节点：组件标签的内容会传递到 this.props.children属性中，反过来通过指定标签的 children 属性可以修改组件标签内容 // MyNavLink 组件 import React, &amp;#123; Component &amp;#125; from 'react' import &amp;#123; NavLink &amp;#125; from 'react-router-dom' export default class MyNavLink extends Component &amp;#123; render() &amp;#123; // this.props.children 可以取到标签内容，如 About, Home // 反过来通过指定标签的 children 属性可以修改标签内容 return &lt;NavLink activeClassName=\"demo\" className=\"list-group-item\" &amp;#123;...this.props&amp;#125; /> &amp;#125; &amp;#125; &lt;MyNavLink to=\"/about\">About&lt;/MyNavLink> &lt;MyNavLink to=\"/home\">Home&lt;/MyNavLink> Switch 的使用Switch可以提高路由匹配效率，如果匹配成功，则不再继续匹配后面的路由，即为单一匹配 &lt;Switch> &lt;Route path='/about' component=&amp;#123;About&amp;#125;/> &lt;Route path='/home' component=&amp;#123;Home&amp;#125;/> &lt;Route path='/home' component=&amp;#123;Test&amp;#125;/> &lt;/Switch> 解决多级路径刷新页面样式丢失的问题 public/index.html 中引入样式时不写./写/（常用） public/index.html中引入样式时不写./写%PUBLIC_URL%（常用） 使用HashRouter &lt;link rel=\"stylesheet\" href=\"/css/bootstrap.css\" /> &lt;link rel=\"stylesheet\" href=\"%PUBLIC_URL%/css/bootstrap.css\" />","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"10.5(受控非受控组件)","slug":"10.5","date":"2022-10-08T07:59:55.168Z","updated":"2022-10-09T08:31:40.321Z","comments":true,"path":"2022/10/08/10.5/","link":"","permalink":"http://engravesunny.github.io/2022/10/08/10.5/","excerpt":"","text":"受控 &amp; 非受控组件包含表单的组件分类： 非受控组件：现用现取。即需要时使用，再获取节点得到数据 受控组件：类似于Vue双向绑定的从视图层绑定到数据 尽量使用受控组件，因为非受控组件要使用大量的ref //非受控组件 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; handleSubmit = (event)=>&amp;#123; event.preventDefault(); const &amp;#123;username,password&amp;#125; = this alert( `您的用户名为$&amp;#123;username.value&amp;#125;，密码为$&amp;#123;password.value&amp;#125;` ) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;form onSubmit=&amp;#123; this.handleSubmit &amp;#125;> 用户名：&lt;input ref=&amp;#123;c=>this.username=c&amp;#125; type=\"text\" name='username'/>&lt;br/> 密码 ：&lt;input ref=&amp;#123;c=>this.password=c&amp;#125; type=\"password\" name='password'/>&lt;br/> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render( &lt;Demo>&lt;/Demo>,document.getElementById('test') ) &lt;/script> //受控组件 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; state = &amp;#123; username:'', password:'' &amp;#125; saveUserName = (event)=> &amp;#123; this.setState(&amp;#123;username:event.target.value&amp;#125;) &amp;#125; savePassword = (event)=> &amp;#123; this.setState(&amp;#123;password:event.target.value&amp;#125;) &amp;#125; handleSubmit = (event)=> &amp;#123; event.preventDefault(); const &amp;#123;username,password&amp;#125; = this.state; alert( `您的用户名为$&amp;#123; username &amp;#125;,密码为$&amp;#123; password &amp;#125;` ) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;form onSubmit=&amp;#123;this.handleSubmit&amp;#125;> &lt;input onChange=&amp;#123;this.saveUserName&amp;#125; type=\"text\"/> &lt;input onChange=&amp;#123;this.savePassword&amp;#125; type=\"password\"/> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 高阶函数_函数柯里化对上述受控组件代码进行优化，希望把saveUserName和savePassword合并为一个函数要点： 高阶函数：参数为函数或者返回一个函数的函数，如Promise、setTimeout、Array.map() 函数柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式 //函数柯里化 function sum(a)&amp;#123; return (b)=>&amp;#123; return (c)&amp;#123; return a + b + c; &amp;#125; &amp;#125; &amp;#125; //使用高阶函数和函数柯里化 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; state = &amp;#123; username:'', password:'' &amp;#125; saveFormData = (dataType)=>&amp;#123; return (event)=>&amp;#123; this.setState(&amp;#123;[dataType]:event.target.value&amp;#125;) &amp;#125; &amp;#125; handleSubmit = (event)=> &amp;#123; event.preventDefault(); const &amp;#123;username,password&amp;#125; = this.state; alert( `您的用户名为$&amp;#123; username &amp;#125;,密码为$&amp;#123; password &amp;#125;` ) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;form onSubmit=&amp;#123;this.handleSubmit&amp;#125;> &lt;input onChange=&amp;#123;this.saveFormData('username')&amp;#125; type=\"text\"/> &lt;input onChange=&amp;#123;this.saveFormData('password')&amp;#125; type=\"password\"/> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> //不使用柯里化写法 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; state = &amp;#123; username:'', password:'' &amp;#125; saveFormData = (dataType,event)=>&amp;#123; this.setState(&amp;#123;[dataType]:event.target.value&amp;#125;) &amp;#125; handleSubmit = (event)=> &amp;#123; event.preventDefault(); const &amp;#123;username,password&amp;#125; = this.state; alert( `您的用户名为$&amp;#123; username &amp;#125;,密码为$&amp;#123; password &amp;#125;` ) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;form onSubmit=&amp;#123;this.handleSubmit&amp;#125;> &lt;input onChange=&amp;#123;event=>this.saveFormData('username',event)&amp;#125; type=\"text\"/> &lt;input onChange=&amp;#123;event=>this.saveFormData('password',event)&amp;#125; type=\"password\"/> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 生命周期生命周期旧版初始化阶段：ReactDOM.render()触发的初次渲染 constructor componentWillMount render componentDidMount &#x3D;&#x3D;&#x3D;&gt; 常用 一般在这个钩子中做一些初始化的事：如：开启定时器，发送网络请求，订阅消息 更新阶段： 1.父组件重新render触发的更新 componentWillReceiveProps shouldComponentUpdate ：控制组件是否更新的阀门，返回值为布尔值，默认为true。若返回 false ，则后续流程不会进行。 componentWillUpdate render componentDidUpdate 2.组件内部调用this.setState()修改状态 shouldComponentUpdate componentWillUpdate render componentDidUpdate 3.组件内部调用this.forceUpdate()强制更新 componentWillUpdate render componentDidUpdate &#x3D;&#x3D;&#x3D;&gt; 常用 一般在这个钩子里做一些收尾的事，例如：关闭定时器，取消订阅消息 卸载阶段:ReactDOM.unmountComponentAtNode()触发 componentWillUnmount 生命周期新版更改内容 废弃三个钩子：componentWillMount、componentWillReceiveProps、componentWillUpdate。在新版本中这三个钩子需要加UNSAFE_前缀，后续可能会废弃 新增两个钩子（实际场景用的很少）：getDerivedStateFromProps、getSnapshotBeforeUpdate static getDerivedStateFromProps(props, state)： 需使用 static 修饰 需返回一个对象更新 state或返回 null 适用于如下情况：state 的值任何时候都取决于prop getSnapshotBeforeUpdate(prevProps, prevState)： 在组件更新之前获取快照 得组件能在发生更改之前从 DOM中捕获一些信息（如滚动位置） 返回值将作为参数传递给 componentDidUpdate() static getDerivedStateFromProps(props,state)&amp;#123; console.log('getDerivedStateFromProps',props,state); return null &amp;#125; getSnapshotBeforeUpdate()&amp;#123; console.log('getSnapshotBeforeUpdate'); return 'atguigu' &amp;#125; componentDidUpdate(preProps,preState,snapshotValue)&amp;#123; console.log('componentDidUpdate',preProps,preState,snapshotValue); &amp;#125; 最重要的三个钩子 render ：初始化渲染和更新渲染 componentDidMount ：进行初始化，如开启定时器、发送网络请求、订阅消息 componentWillUnmount ：进行收尾，如关闭定时器、取消订阅消息 虚拟 DOM 与 Diff 算法 key的作用key 是虚拟 DOM 对象的标识，可提高页面更新渲染的效率。 当状态中的数据发生变化时，React 会根据新数据生成新的虚拟 DOM ，接着对新旧虚拟 DOM 进行 Diff 比较，规则如下： 旧虚拟 DOM 找到和新虚拟 DOM 相同的 key： 若内容没变，直接复用真实 DOM 若内容改变，则生成新的真实 DOM ，替换页面中之前的真实 DOM 旧虚拟 DOM 未找到和新虚拟 DOM 相同的 key：根据数据创建新的真实 DOM ，渲染到页面 使用 index 作为 key 可能引发的问题： 若对数据进行逆序添加、逆序删除等破坏顺序的操作，会进行没有必要的真实 DOM 更新。界面效果没问题，但效率低下。 如果结构中包含输入类的 DOM（如 input 输入框） ，则会产生错误的 DOM 更新。 若不存在对数据逆序添加、逆序删除等破坏顺序的操作，则没有问题。","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}],"categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"},{"name":"博客修改","slug":"博客修改","permalink":"http://engravesunny.github.io/categories/%E5%8D%9A%E5%AE%A2%E4%BF%AE%E6%94%B9/"},{"name":"博客","slug":"博客","permalink":"http://engravesunny.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"博客修改","slug":"博客修改","permalink":"http://engravesunny.github.io/tags/%E5%8D%9A%E5%AE%A2%E4%BF%AE%E6%94%B9/"},{"name":"博客","slug":"博客","permalink":"http://engravesunny.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]}